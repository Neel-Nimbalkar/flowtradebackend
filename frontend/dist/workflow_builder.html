<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Trades - Workflow Builder</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #131722;
            color: #d1d4dc;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar with block palette */
        .sidebar {
            width: 240px;
            background: #1e222d;
            border-right: 1px solid #2a2e39;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding-bottom: 80px;
        }

        /* Custom scrollbar for sidebar */
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #131722;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #2962ff;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #5e8cff;
        }

        .sidebar-header {
            padding: 14px 16px;
            background: #1e222d;
            border-bottom: 1px solid #2a2e39;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sidebar-header h2 {
            font-size: 14px;
            font-weight: 600;
            color: #f8f9fa;
            margin-bottom: 4px;
            letter-spacing: -0.2px;
            text-transform: uppercase;
        }

        .sidebar-header p {
            font-size: 11px;
            color: #787b86;
            line-height: 1.3;
        }

        .block-category {
            padding: 8px 12px;
            border-bottom: 1px solid #2a2e39;
        }

        .category-search {
            width: 100%;
            padding: 4px 8px;
            margin-bottom: 6px;
            background: #131722;
            border: 1px solid #2a2e39;
            border-radius: 2px;
            color: #d1d4dc;
            font-size: 10px;
            outline: none;
            transition: border-color 0.15s ease;
        }

        .category-search::placeholder {
            color: #787b86;
        }

        .category-search:focus {
            border-color: #2962ff;
        }

        .category-search:hover {
            border-color: #363a45;
        }

        .block-item.hidden {
            display: none;
        }

        .category-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: #787b86;
            margin-bottom: 6px;
            letter-spacing: 0.8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 6px;
            border-radius: 2px;
            transition: background 0.15s ease;
            user-select: none;
        }

        .category-title:hover {
            background: #1b1f27;
            color: #d1d4dc;
        }

        .category-title::after {
            content: '▼';
            font-size: 8px;
            transition: transform 0.2s ease;
        }

        .block-category.collapsed .category-title::after {
            transform: rotate(-90deg);
        }

        .category-blocks {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .block-category.collapsed .category-blocks {
            max-height: 0;
            opacity: 0;
        }

        .block-item {
            padding: 3px 8px;
            margin-bottom: 1px;
            background: transparent;
            border: none;
            border-radius: 2px;
            cursor: grab;
            transition: background 0.12s ease, color 0.12s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 24px;
        }

        .block-item::before {
            display: none;
        }

        .block-item:hover::before {
            display: none;
        }

        .block-item:hover {
            background: #1b1f27;
        }

        .block-item:active {
            cursor: grabbing;
        }

        .block-icon {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
        }

        .block-info {
            flex: 1;
            min-width: 0;
        }

        .block-name {
            font-size: 12.5px;
            font-weight: 500;
            color: #d1d4dc;
        }

        .block-desc {
            display: none;
        }

        /* Canvas area */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #0f1116;
            background-image:
                radial-gradient(#262a33 1px, transparent 1px),
                radial-gradient(#262a33 1px, transparent 1px);
            background-position: 0 0, 7.5px 7.5px;
            background-size: 15px 15px;
        }

        .canvas {
            position: absolute;
            width: 5000px;
            height: 5000px;
            cursor: grab;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .canvas.panning {
            cursor: grabbing;
        }

        .canvas.dragging-node {
            cursor: default;
        }

        /* Node on canvas */
        .node {
            position: absolute;
            background: #161a20;
            border: 1px solid #2a2e39;
            border-radius: 6px;
            min-width: 220px;
            cursor: move;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
            transition: border-color 0.12s ease;
        }

        .node:hover {
            border-color: #3a3f47;
        }

        .node.selected {
            border-color: #2962ff;
        }

        .node.executing {
            border-color: #089981;
            animation: pulse-execute 0.8s ease-in-out;
        }

        .node.node-passed {
            border-color: #089981;
        }

        .node.node-failed {
            border-color: #f23645;
        }

        .node.node-skipped {
            opacity: 0.5;
            border-color: #2a2e39;
        }

        @keyframes pulse-execute {
            0%, 100% { box-shadow: 0 0 0 2px rgba(8, 153, 129, 0.3); }
            50% { box-shadow: 0 0 0 4px rgba(8, 153, 129, 0.2); }
        }

        .node-header {
            padding: 6px 10px;
            background: #131722;
            border-bottom: 1px solid #2a2e39;
            border-radius: 6px 6px 0 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .node-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
        }

        .node-title {
            flex: 1;
            font-size: 12px;
            font-weight: 600;
            color: #f8f9fa;
            letter-spacing: -0.1px;
        }

        .node-body {
            padding: 8px 10px;
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }

        .node-inputs {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .node-outputs {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: flex-end;
        }

        .node-port {
            font-size: 10px;
            color: #787b86;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
            cursor: pointer;
            padding: 2px 0;
            transition: color 0.15s;
            white-space: nowrap;
        }

        .node-port:hover {
            color: #d1d4dc;
        }

        .node-port.input {
            justify-content: flex-start;
        }

        .node-port.output {
            justify-content: flex-end;
            text-align: right;
        }

        .port-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #2a2e39;
            border: 2px solid #787b86;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
            z-index: 10;
            flex-shrink: 0;
        }

        .port-dot:hover {
            background: #2962ff;
            border-color: #2962ff;
            transform: scale(1.2);
            box-shadow: 0 0 8px rgba(41, 98, 255, 0.5);
        }

        .port-dot.connected {
            background: #089981;
            border-color: #089981;
        }

        /* Larger invisible clickable halo to make connecting easier */
        .port-dot::after {
            content: '';
            position: absolute;
            top: -8px;
            left: -8px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            /* Transparent but keeps pointer events */
            background: transparent;
        }

        .port-dot.targetable:not(.connected) {
            box-shadow: 0 0 0 4px rgba(96,165,250,0.25);
        }

        .node-port.output {
            justify-content: flex-end;
        }

        .node-delete {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background: transparent;
            border: 1px solid #2a2e39;
            color: #787b86;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            font-size: 14px;
        }

        .node-delete:hover {
            background: #f23645;
            border-color: #f23645;
            color: white;
        }

        /* Connections/wires */
        .connection-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connection-wire {
            stroke: #6e7380;
            stroke-width: 2.5;
            fill: none;
            opacity: 0.8;
            transition: all 0.15s;
            shape-rendering: crispEdges;
            marker-end: url(#arrowhead);
        }

        .connection-wire:hover {
            stroke: #2962ff;
            stroke-width: 3;
            opacity: 1;
        }

        .connection-wire.temp {
            stroke: #787b86;
            stroke-dasharray: 5, 5;
            opacity: 0.5;
        }

        /* Toolbar */
        .toolbar {
            position: absolute;
            top: 16px;
            right: 16px;
            background: #1e222d;
            border: 1px solid #2a2e39;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            gap: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .toolbar-btn {
            padding: 8px 14px;
            background: #131722;
            border: 1px solid #2a2e39;
            border-radius: 4px;
            color: #d1d4dc;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-btn::before {
            display: none;
        }

        .toolbar-btn:hover::before {
            display: none;
        }

        .toolbar-btn:hover {
            background: #1e222d;
            border-color: #2962ff;
            color: #f8f9fa;
        }

        .toolbar-btn:active {
            transform: translateY(1px);
        }

        .toolbar-btn.primary {
            background: #2962ff;
            border-color: #2962ff;
            color: white;
        }

        .toolbar-btn.primary:hover {
            background: #5e8cff;
            border-color: #5e8cff;
        }

        .toolbar-btn.success {
            background: #089981;
            border-color: #089981;
            color: white;
        }

        .toolbar-btn.success:hover {
            background: #0cb89b;
            border-color: #0cb89b;
        }

        /* Insights toggle button: n8n reddish-pink */
        .toolbar-btn.insights-btn {
            background: #ff3366;
            border-color: #ff3366;
            color: #ffffff;
            box-shadow: 0 1px 0 rgba(0,0,0,0.04) inset;
        }

        /* Zoom controls */
        .zoom-controls {
            position: absolute;
            bottom: 160px;
            right: 16px;
            background: #1e222d;
            border: 1px solid #2a2e39;
            border-radius: 4px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: #131722;
            border: 1px solid #2a2e39;
            border-radius: 4px;
            color: #d1d4dc;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .zoom-btn:hover {
            background: #1e222d;
            border-color: #2962ff;
            color: #f8f9fa;
        }

        .zoom-level {
            font-size: 10px;
            font-weight: 600;
            color: #787b86;
            text-align: center;
            padding: 4px 0;
        }

        /* Minimap */
        .minimap {
            position: absolute;
            bottom: 160px;
            right: 80px;
            width: 180px;
            height: 120px;
            background: #1e222d;
            border: 1px solid #2a2e39;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .minimap-viewport {
            position: absolute;
            border: 2px solid #2962ff;
            background: rgba(41, 98, 255, 0.1);
            pointer-events: none;
        }

        /* Status bar */
        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 36px;
            background: #1e222d;
            border-top: 1px solid #2a2e39;
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            font-size: 11px;
            color: #787b86;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #10b981;
        }

        /* Color schemes for different block types */
        .color-input { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); }
        .color-indicator { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); }
        .color-logic { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }
        .color-output { background: linear-gradient(135deg, #10b981 0%, #059669 100%); }
        .color-volume { background: linear-gradient(135deg, #ec4899 0%, #db2777 100%); }
        .color-config { background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%); }

        /* Mini-map removed */

        /* ========== PREMIUM RESULTS PANEL (Pro Style) ========== */
        .output-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 480px;
            height: 100vh;
            background: #1e222d;
            border-left: 1px solid #2a2e39;
            transform: translateX(100%);
            transition: transform 0.2s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
        }

        .output-panel-resize-handle {
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            cursor: ew-resize;
            background: transparent;
            z-index: 10;
            transition: background 0.15s ease;
        }

        .output-panel-resize-handle:hover,
        .output-panel-resize-handle.resizing {
            background: #2a2e39;
        }

        .output-panel.open {
            transform: translateX(0);
        }

        /* Premium Header with Status Badge */
        .output-header {
            padding: 14px 16px;
            background: #1e222d;
            border-bottom: 1px solid #2a2e39;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .output-header-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .output-header-title-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .output-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #f8f9fa;
            margin: 0;
            letter-spacing: -0.2px;
            line-height: 1.2;
            text-transform: uppercase;
        }

        .output-header-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 10px;
            color: #787b86;
            text-transform: none;
        }

        .output-status-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            background: transparent;
        }

        .output-status-badge.completed {
            color: #089981;
            border: 1px solid #089981;
        }

        .output-status-badge.failed {
            color: #f23645;
            border: 1px solid #f23645;
        }

        .output-status-badge.stopped {
            color: #787b86;
            border: 1px solid #787b86;
        }

        .output-header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .output-action-btn {
            background: transparent;
            border: 1px solid #2a2e39;
            color: #d1d4dc;
            padding: 4px 8px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.12s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .output-action-btn:hover {
            background: #1b1f27;
            border-color: #2a2e39;
            color: #f8f9fa;
        }

        .output-close {
            background: transparent;
            border: 1px solid #2a2e39;
            color: #787b86;
            width: 24px;
            height: 24px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.12s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .output-close:hover {
            background: transparent;
            border-color: #f23645;
            color: #f23645;
        }

        .output-tabs {
            display: flex;
            gap: 0;
            background: transparent;
            padding: 0;
            border: none;
        }

        .output-tab {
            background: transparent;
            border: none;
            color: #787b86;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 0;
            transition: color 0.12s ease;
            position: relative;
            display: flex;
            align-items: center;
            gap: 6px;
            border-bottom: 1px solid transparent;
        }

        .output-tab:hover {
            color: #d1d4dc;
        }

        .output-tab.active {
            color: #d1d4dc;
            border-bottom-color: #2a2e39;
        }

        .output-tab-icon {
            font-size: 14px;
        }

        /* Content Area */
        .output-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            background: #1e222d;
        }

        /* Custom scrollbar */
        .output-content::-webkit-scrollbar {
            width: 6px;
        }

        .output-content::-webkit-scrollbar-track {
            background: #131722;
        }

        .output-content::-webkit-scrollbar-thumb {
            background: #2962ff;
            border-radius: 3px;
        }

        .output-content::-webkit-scrollbar-thumb:hover {
            background: #5e8cff;
        }

        /* Premium Section Cards */
        .output-section {
            margin-bottom: 12px;
            padding: 0;
            background: transparent;
            border: none;
            border-radius: 0;
        }

        .output-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: transparent;
            border: none;
            border-bottom: 1px solid #2a2e39;
            border-radius: 0;
            cursor: pointer;
            transition: background 0.12s ease;
        }

        .output-section-header:hover {
            background: #1b1f27;
        }

        .output-section-title {
            font-size: 10px;
            font-weight: 600;
            color: #787b86;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .output-section-toggle {
            color: #787b86;
            font-size: 12px;
            transition: transform 0.2s ease;
        }

        .output-section-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .output-section-body {
            padding: 12px;
            background: transparent;
            border: none;
            border-radius: 0;
        }

        .output-section.collapsed .output-section-body {
            display: none;
        }

        /* Overview Grid */
        .overview-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .overview-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .overview-label {
            font-size: 10px;
            color: #787b86;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .overview-value {
            font-size: 13px;
            color: #d1d4dc;
            font-weight: 500;
        }

        /* Timeline Styles */
        .timeline-container {
            position: relative;
        }

        .timeline-item {
            position: relative;
            padding: 10px 0 10px 32px;
            border-left: 1px solid #2a2e39;
            margin-left: 10px;
        }

        .timeline-item:last-child {
            border-left-color: transparent;
        }

        .timeline-dot {
            position: absolute;
            left: -5px;
            top: 14px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 2px solid #1e222d;
            background: #2a2e39;
        }

        .timeline-item.passed .timeline-dot {
            background: #089981;
            border-color: #089981;
        }

        .timeline-item.failed .timeline-dot {
            background: #f23645;
            border-color: #f23645;
        }

        .timeline-item.skipped .timeline-dot {
            background: #787b86;
            border-color: #787b86;
        }

        .timeline-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .timeline-emoji {
            font-size: 18px;
        }

        .timeline-title {
            font-size: 12.5px;
            font-weight: 500;
            color: #d1d4dc;
            flex: 1;
        }

        .timeline-status {
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            background: transparent;
            border: 1px solid;
        }

        .timeline-status.passed {
            color: #089981;
            border-color: #089981;
        }

        .timeline-status.failed {
            color: #f23645;
            border-color: #f23645;
        }

        .timeline-status.skipped {
            color: #787b86;
            border-color: #787b86;
        }

        .timeline-time {
            font-size: 10px;
            color: #787b86;
            margin-left: auto;
        }

        .timeline-outputs {
            background: transparent;
            border: 1px solid #2a2e39;
            border-radius: 2px;
            padding: 8px;
            margin: 6px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #d1d4dc;
            line-height: 1.5;
        }

        .timeline-explanation {
            font-size: 12px;
            color: #787b86;
            line-height: 1.5;
            margin: 6px 0;
        }

        .timeline-expand {
            background: transparent;
            border: 1px solid #2a2e39;
            color: #787b86;
            padding: 4px 8px;
            border-radius: 2px;
            font-size: 10px;
            cursor: pointer;
            margin-top: 6px;
            transition: all 0.12s ease;
        }

        .timeline-expand:hover {
            background: #1b1f27;
            border-color: #2a2e39;
            color: #d1d4dc;
        }

        /* Execution Table - Excel Style */
        .execution-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: #131722;
            border: 1px solid #2a2e39;
        }

        .execution-table thead {
            background: #1e222d;
            border-bottom: 1px solid #2a2e39;
        }

        .execution-table th {
            padding: 8px 10px;
            text-align: left;
            font-weight: 600;
            color: #787b86;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
            border-right: 1px solid #2a2e39;
        }

        .execution-table th:last-child {
            border-right: none;
        }

        .execution-table td {
            padding: 8px 10px;
            border-bottom: 1px solid #2a2e39;
            border-right: 1px solid #2a2e39;
            color: #d1d4dc;
        }

        .execution-table td:last-child {
            border-right: none;
        }

        .execution-table tbody tr:hover {
            background: #1b1f27;
        }

        .execution-table tbody tr:last-child td {
            border-bottom: none;
        }

        .table-cell-name {
            font-weight: 500;
            color: #d1d4dc;
        }

        .table-cell-status {
            font-size: 10px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .table-cell-status.status-passed {
            color: #089981;
        }

        .table-cell-status.status-failed {
            color: #f23645;
        }

        .table-cell-status.status-skipped {
            color: #787b86;
        }

        .table-cell-output {
            color: #787b86;
            font-size: 10px;
            font-family: monospace;
        }

        .table-cell-time {
            color: #787b86;
            font-size: 10px;
            text-align: right;
            font-family: monospace;
        }

        /* AI Summary Box */
        .ai-summary-box {
            background: #131722;
            border: 1px solid #2a2e39;
            padding: 12px;
            border-radius: 2px;
            color: #d1d4dc;
            font-size: 12px;
            line-height: 1.6;
        }

        /* Signals Table */
        .signals-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
            background: #131722;
            border: 1px solid #2a2e39;
        }

        .signals-table thead {
            background: #1e222d;
            border-bottom: 1px solid #2a2e39;
        }

        .signals-table th {
            padding: 8px 10px;
            text-align: left;
            font-weight: 600;
            color: #787b86;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
            border-right: 1px solid #2a2e39;
        }

        .signals-table th:last-child {
            border-right: none;
        }

        .signals-table td {
            padding: 8px 10px;
            border-bottom: 1px solid #2a2e39;
            border-right: 1px solid #2a2e39;
        }

        .signals-table td:last-child {
            border-right: none;
        }

        .signals-table tbody tr:hover {
            background: #1b1f27;
        }

        .signals-table tbody tr:last-child td {
            border-bottom: none;
        }

        .signal-time {
            color: #787b86;
            font-size: 10px;
        }

        .signal-action {
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
        }

        .signal-action.signal-buy {
            color: #089981;
        }

        .signal-action.signal-sell {
            color: #f23645;
        }

        .signal-action.signal-hold {
            color: #787b86;
        }

        .signal-price {
            color: #d1d4dc;
            font-size: 11px;
            font-family: monospace;
        }

        /* Final Decision Card */
        .decision-card {
            background: transparent;
            border: 1px solid #2a2e39;
            border-radius: 2px;
            padding: 16px;
            text-align: center;
        }

        .decision-signal {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }

        .decision-signal.buy {
            color: #089981;
        }

        .decision-signal.sell {
            color: #f23645;
        }

        .decision-signal.hold {
            color: #787b86;
        }

        .decision-confidence {
            font-size: 13px;
            color: #787b86;
            margin-bottom: 16px;
        }

        .decision-ai-note {
            background: transparent;
            border: 1px solid #2a2e39;
            border-radius: 2px;
            padding: 12px;
            margin-top: 12px;
            text-align: left;
        }

        .decision-ai-label {
            font-size: 10px;
            color: #787b86;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .decision-ai-text {
            font-size: 12px;
            color: #d1d4dc;
            line-height: 1.6;
            max-height: 180px;
            overflow-y: auto;
        }

        /* Chart Container */
        .chart-container {
            background: transparent;
            border: 1px solid #2a2e39;
            border-radius: 2px;
            padding: 12px;
            margin-top: 12px;
        }

        .chart-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .chart-title {
            font-size: 11px;
            font-weight: 600;
            color: #787b86;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .chart-toggle {
            background: transparent;
            border: 1px solid #2a2e39;
            color: #787b86;
            padding: 4px 8px;
            border-radius: 2px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.12s ease;
        }

        .chart-toggle:hover {
            background: #1b1f27;
            border-color: #2a2e39;
            color: #d1d4dc;
        }

        .chart-canvas-wrapper {
            position: relative;
            width: 100%;
            height: 280px;
            background: #131722;
            border: 1px solid #2a2e39;
            border-radius: 2px;
        }

        #equityCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* ========== BOTTOM DRAWER CHART PANEL ========== */
        .chart-drawer {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            /* adjusted closed handle per request; set to 40px */
            height: 40px;
            background: #1e222d;
            border-top: 1px solid #2a2e39;
            box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.3);
            z-index: 900;
            transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            /* prevent internal chart/canvas from peeking out when closed */
            overflow: hidden;
        }

        .chart-drawer.expanded {
            height: 400px;
            /* allow content to be visible when expanded */
            overflow: visible;
        }

        .chart-drawer.fullscreen {
            height: calc(100vh - 60px);
        }

        /* ========== PREMIUM RESULTS PANEL ========== */
        .results-panel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 420px;
            height: 100vh;
            background: #1e222d;
            border-left: 1px solid #2a2e39;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.3);
            z-index: 950;
            transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .results-panel.open {
            right: 0;
        }

        .results-panel-header {
            padding: 16px 20px;
            background: linear-gradient(135deg, #1e222d 0%, #23272f 100%);
            border-bottom: 1px solid #2a2e39;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .results-panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #f8f9fa;
            letter-spacing: -0.3px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .results-panel-icon {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #2962ff 0%, #5e8cff 100%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
        }

        .results-panel-close {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            background: transparent;
            border: 1px solid #2a2e39;
            color: #787b86;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            font-size: 16px;
        }

        .results-panel-close:hover {
            background: #f23645;
            border-color: #f23645;
            color: white;
        }

        .results-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .results-panel-body::-webkit-scrollbar {
            width: 6px;
        }

        .results-panel-body::-webkit-scrollbar-track {
            background: #131722;
        }

        .results-panel-body::-webkit-scrollbar-thumb {
            background: #2962ff;
            border-radius: 3px;
        }

        .results-section {
            padding: 20px;
            border-bottom: 1px solid #2a2e39;
        }

        .results-section:last-child {
            border-bottom: none;
        }

        .results-section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }

        .results-section-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .results-section-icon.ai {
            background: linear-gradient(135deg, rgba(41, 98, 255, 0.15) 0%, rgba(94, 140, 255, 0.1) 100%);
            color: #5e8cff;
            border: 2px solid #2962ff;
            font-weight: 700;
            font-size: 12px;
        }

        .results-section-icon.signals {
            background: linear-gradient(135deg, rgba(41, 98, 255, 0.15) 0%, rgba(94, 140, 255, 0.1) 100%);
            color: #60a5fa;
        }

        .results-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #f8f9fa;
            letter-spacing: -0.2px;
        }

        .results-section-subtitle {
            font-size: 11px;
            color: #787b86;
            margin-top: 2px;
        }

        .ai-analysis-box {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.08) 0%, rgba(168, 85, 247, 0.05) 100%);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 8px;
            padding: 16px;
            line-height: 1.6;
        }

        .ai-analysis-label {
            font-size: 10px;
            font-weight: 600;
            color: #a78bfa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ai-analysis-text {
            font-size: 12px;
            color: #d1d4dc;
            line-height: 1.7;
            margin-bottom: 12px;
        }

        .ai-analysis-text:last-child {
            margin-bottom: 0;
        }

        .ai-analysis-highlight {
            color: #a78bfa;
            font-weight: 500;
        }

        .ai-status-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-top: 12px;
            margin-top: 12px;
            border-top: 1px solid rgba(139, 92, 246, 0.15);
            font-size: 11px;
        }

        .ai-status-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #787b86;
        }

        .ai-status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #22c55e;
            animation: pulse-dot 2s ease-in-out infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .signal-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .signal-item {
            background: #23272f;
            border: 1px solid #2a2e39;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }

        .signal-item:hover {
            background: #2a2e39;
            border-color: #2962ff;
            transform: translateX(-2px);
        }

        .signal-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .signal-type {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
        }

        .signal-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .signal-icon.buy {
            background: rgba(34, 197, 94, 0.15);
            color: #22c55e;
        }

        .signal-icon.sell {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }

        .signal-icon.neutral {
            background: rgba(107, 114, 128, 0.15);
            color: #9ca3af;
        }

        .signal-type-text {
            color: #f8f9fa;
        }

        .signal-timestamp {
            font-size: 10px;
            color: #787b86;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .signal-item-body {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .signal-price {
            font-size: 15px;
            font-weight: 600;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        .signal-price.buy {
            color: #22c55e;
        }

        .signal-price.sell {
            color: #ef4444;
        }

        .signal-price.neutral {
            color: #9ca3af;
        }

        .signal-trigger {
            font-size: 10px;
            color: #787b86;
            background: #1e222d;
            padding: 4px 8px;
            border-radius: 3px;
            border: 1px solid #2a2e39;
        }

        .signal-empty {
            text-align: center;
            padding: 40px 20px;
            color: #787b86;
        }

        .signal-empty-icon {
            font-size: 32px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .signal-empty-text {
            font-size: 12px;
            line-height: 1.6;
        }

        .results-panel-toggle {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 940;
            transition: right 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .results-panel.open ~ .results-panel-toggle {
            right: 436px;
        }

        .chart-drawer-handle {
            width: 100%;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            background: #1e222d;
            border-bottom: 1px solid #2a2e39;
            user-select: none;
        }

        .chart-drawer-handle:active {
            cursor: grabbing;
        }

        .chart-drawer-grip {
            width: 40px;
            height: 4px;
            background: #2a2e39;
            border-radius: 2px;
            transition: background 0.15s ease;
        }

        .chart-drawer-handle:hover .chart-drawer-grip {
            background: #2962ff;
        }

        .chart-drawer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: #1e222d;
            border-bottom: 1px solid #2a2e39;
        }

        .chart-drawer-title {
            font-size: 11px;
            font-weight: 600;
            color: #787b86;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .chart-drawer-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .chart-drawer-btn {
            background: transparent;
            border: 1px solid #2a2e39;
            color: #787b86;
            padding: 4px 8px;
            border-radius: 2px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.12s ease;
            font-weight: 500;
        }

        .chart-drawer-btn:hover {
            background: #1b1f27;
            border-color: #2a2e39;
            color: #d1d4dc;
        }

        .chart-drawer-btn.active {
            background: #2962ff;
            border-color: #2962ff;
            color: white;
        }

        .chart-drawer-body {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #131722;
        }

        .chart-drawer-canvas-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* `#drawerStrategyChart` removed — legacy strategy/backtest canvas no longer used */

        .chart-drawer-tooltip {
            position: absolute;
            background: rgba(30, 34, 45, 0.95);
            border: 1px solid #2a2e39;
            border-radius: 4px;
            padding: 8px 10px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            font-size: 11px;
            color: #d1d4dc;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .chart-drawer-tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            margin: 2px 0;
        }

        .chart-drawer-tooltip-label {
            color: #787b86;
            font-weight: 500;
        }

        .chart-drawer-tooltip-value {
            font-weight: 600;
        }

        .chart-drawer-tooltip-value.price {
            color: #2962ff;
        }

        .chart-drawer-tooltip-value.strategy {
            color: #089981;
        }

        .chart-drawer-legend {
            position: absolute;
            top: 12px;
            left: 12px;
            display: flex;
            gap: 16px;
            font-size: 11px;
            z-index: 10;
        }

        .chart-drawer-legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .chart-drawer-legend-color {
            width: 16px;
            height: 2px;
            border-radius: 1px;
        }

        .chart-drawer-legend-label {
            color: #787b86;
            font-weight: 500;
        }

        .chart-drawer-cursor {
            position: absolute;
            width: 1px;
            height: 100%;
            background: rgba(120, 123, 134, 0.5);
            pointer-events: none;
            display: none;
        }

        /* Remove old styles */
        .signal-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 700;
            margin-right: 8px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            transition: none;
        }

        .signal-badge:hover {
            transform: none;
            box-shadow: none;
        }

        .signal-badge.bullish {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: none;
        }

        .signal-badge.bearish {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: none;
        }

        .signal-badge.neutral {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            color: white;
            box-shadow: none;
        }

        .conclusion-box {
            padding: 16px;
            border-radius: 8px;
            border: 1px solid;
            margin-top: 16px;
            position: relative;
            overflow: hidden;
        }

        .conclusion-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, transparent 0%, currentColor 50%, transparent 100%);
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Strategy Performance Chart */
        .strategy-chart-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #0b0f14;
            border-radius: 6px;
            border: 1px solid #1f2937;
            margin-top: 15px;
        }

        .chart-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #0b0f14;
            border-radius: 6px;
            border: 1px solid #1f2937;
        }

        .chart-control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .chart-control-label {
            font-size: 11px;
            color: #9ca3af;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .chart-period-btn {
            padding: 5px 12px;
            background: #11151c;
            border: 1px solid #1f2937;
            border-radius: 4px;
            color: #e5e7eb;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chart-period-btn:hover {
            background: #151a22;
            border-color: #334155;
        }

        .chart-period-btn.active {
            background: #172029;
            border-color: #3b82f6;
            color: #e5e7eb;
        }

        .chart-expand-btn {
            padding: 5px 10px;
            background: #11151c;
            border: 1px solid #1f2937;
            border-radius: 4px;
            color: #e5e7eb;
            font-size: 11px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
            margin-left: auto;
        }

        .chart-expand-btn:hover {
            background: #151a22;
            border-color: #334155;
        }

        .chart-legend {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            margin-top: 8px;
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #9ca3af;
        }

        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }

        .chart-tooltip {
            position: absolute;
            background: #111827;
            border: 1px solid #374151;
            border-radius: 6px;
            padding: 8px 10px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            font-size: 12px;
            color: #e5e7eb;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .chart-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            color: #9ca3af;
        }

        .conclusion-box.bullish {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.15) 0%, rgba(5, 150, 105, 0.05) 100%);
            border-color: #10b981;
            color: #10b981;
        }

        .conclusion-box.bearish {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(220, 38, 38, 0.05) 100%);
            border-color: #ef4444;
            color: #ef4444;
        }

        .conclusion-box.neutral {
            background: linear-gradient(135deg, rgba(107, 114, 128, 0.15) 0%, rgba(75, 85, 99, 0.05) 100%);
            border-color: #6b7280;
            color: #6b7280;
        }

        .conclusion-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .conclusion-title-icon {
            font-size: 24px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .conclusion-text {
            font-size: 14px;
            line-height: 1.8;
            color: #d1d5db;
        }

        /* Heart-monitor style loading indicator: two pulsing bars */
        .loading-spinner {
            display: inline-block;
            width: 24px;
            height: 12px;
            position: relative;
        }

        .loading-spinner::before,
        .loading-spinner::after {
            content: '';
            position: absolute;
            bottom: 0;
            width: 4px;
            height: 100%;
            background: #a78bfa;
            border-radius: 2px;
            transform-origin: center bottom;
            animation: heart-pulse 900ms ease-in-out infinite;
        }

        .loading-spinner::before { left: 4px; }
        .loading-spinner::after { left: 14px; animation-delay: 220ms; }

        @keyframes heart-pulse {
            0%,100% { transform: scaleY(0.6); opacity: 0.7; }
            50% { transform: scaleY(1.6); opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% {
                border-color: #3b4252;
                transform: scale(1);
            }
            50% {
                border-color: #60a5fa;
                transform: scale(1.1);
            }
        }

        @keyframes pulse-dot {
            0%, 100% {
                background: #3b4252;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                background: #60a5fa;
                transform: translate(-50%, -50%) scale(1.3);
            }
        }

        .step-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, rgba(45, 50, 57, 0.6) 0%, rgba(30, 41, 59, 0.6) 100%);
            border-radius: 10px;
            border-left: 4px solid #60a5fa;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .step-indicator:hover {
            transform: translateX(4px);
            border-left-color: #ff8a4b;
            box-shadow: 0 4px 12px rgba(96, 165, 250, 0.2);
        }

        .step-number {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff8a4b 0%, #ffb07a 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 700;
            flex-shrink: 0;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .step-name {
            font-size: 14px;
            color: #e5e7eb;
            font-weight: 600;
        }

        .step-result {
            margin-left: auto;
            font-size: 16px;
            color: #10b981;
        }

        /* Config block input fields */
        .config-input, .config-select {
            width: 100%;
        }

        /* New modern data cards */
        .data-card {
            background: #0b0f14;
            border: 1px solid #1f2937;
            border-radius: 6px;
            padding: 14px;
            transition: border-color 0.2s ease, transform 0.2s ease;
        }

        .data-card:hover {
            border-color: #2b3a4a;
            transform: translateY(-2px);
        }

        .data-card-header {
            font-size: 11px;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .data-card-value {
            font-size: 24px;
            font-weight: 700;
            color: #e5e7eb;
            display: flex;
            align-items: baseline;
            gap: 6px;
        }

        .data-card-change {
            font-size: 14px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .data-card-change.positive {
            color: #10b981;
        }

        .data-card-change.negative {
            color: #ef4444;
        }

        /* Block execution card */
        .block-exec-card {
            padding: 12px;
            margin-bottom: 8px;
            background: #0b0f14;
            border: 1px solid #141922;
            border-left: 3px solid;
            border-radius: 6px;
            transition: border-color 0.2s ease, transform 0.2s ease;
        }

        .block-exec-card:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .block-exec-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
        }

        .block-exec-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .block-exec-title {
            color: #e5e7eb;
            font-weight: 600;
            font-size: 13px;
        }

        .block-exec-time {
            margin-left: auto;
            font-size: 10px;
            color: #6b7280;
            background: rgba(15, 23, 42, 0.6);
            padding: 3px 6px;
            border-radius: 4px;
        }

        .block-exec-message {
            font-size: 13px;
            line-height: 1.6;
            margin-left: 30px;
        }

        /* Indicator signal card */
        .indicator-signal-card {
            padding: 10px;
            margin-bottom: 8px;
            background: #0b0f14;
            border-left: 3px solid;
            border-radius: 6px;
            transition: border-color 0.2s ease, transform 0.2s ease;
        }

        .indicator-signal-card:hover {
            transform: translateX(4px);
        }

        .indicator-signal-name {
            color: #e5e7eb;
            text-transform: uppercase;
            font-weight: 700;
            font-size: 12px;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .indicator-signal-reason {
            font-size: 13px;
            line-height: 1.5;
        }

        /* Stats grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        /* Metric card */
        .metric-card {
            background: #0b0f14;
            border: 1px solid #1f2937;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            transition: border-color 0.2s ease, transform 0.2s ease;
        }

        .metric-card:hover {
            border-color: #2b3a4a;
            transform: scale(1.02);
        }

        .metric-label {
            font-size: 11px;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 22px;
            font-weight: 700;
            color: #e5e7eb;
        }

        /* AI Analysis card special styling */
        .ai-analysis-card {
            background: #0b0f14;
            border: 1px solid #1f2937;
            border-radius: 6px;
            padding: 14px;
            margin-top: 10px;
        }

        .ai-analysis-text {
            color: #e5e7eb;
            font-size: 14px;
            line-height: 1.8;
            white-space: pre-wrap;
        }

        .ai-meta {
            margin-top: 14px;
            padding-top: 14px;
            border-top: 1px solid rgba(96, 165, 250, 0.2);
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: #9ca3af;
        }

        .ai-meta strong {
            color: #60a5fa;
        }

        .config-input, .config-select {
            padding: 6px 10px;
            background: #1a1d23;
            border: 1px solid #3b4252;
            border-radius: 4px;
            color: #e5e7eb;
            font-size: 13px;
            font-family: inherit;
            margin-top: 6px;
        }

        .config-input:focus, .config-select:focus {
            outline: none;
            border-color: #60a5fa;
        }

        .config-label {
            font-size: 11px;
            color: #9ca3af;
            font-weight: 500;
            display: block;
            margin-bottom: 2px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar with block palette -->
        <div class="sidebar">
            <div class="sidebar-header">
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
                    <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#2962ff;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#5e8cff;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <path d="M4 8 L16 8 L16 12 L4 12 Z" fill="url(#logoGradient)" opacity="0.9"/>
                        <path d="M4 14 L28 14 L28 18 L4 18 Z" fill="url(#logoGradient)"/>
                        <path d="M4 20 L22 20 L22 24 L4 24 Z" fill="url(#logoGradient)" opacity="0.8"/>
                        <circle cx="26" cy="10" r="2" fill="#5e8cff"/>
                        <circle cx="24" cy="22" r="2" fill="#2962ff"/>
                    </svg>
                    <h2 style="font-size:16px;font-weight:700;color:#f8f9fa;margin:0;">Flow Trades</h2>
                </div>
                <p>Drag blocks to canvas to build your strategy</p>
            </div>

            <div class="block-category">
                <div class="category-title">Strategy Templates</div>
                <div class="category-blocks">
                <!-- removed -->
                <div class="block-item" draggable="true" data-block-type="template-golden-cross">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">Golden Cross</div>
                        <div class="block-desc">50/200 SMA crossover</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="template-rsi-volume">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">RSI + Volume Spike</div>
                        <div class="block-desc">Oversold with volume confirmation</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="template-trend-following">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">Trend Following</div>
                        <div class="block-desc">EMA + MACD momentum</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="template-mean-reversion">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">Mean Reversion</div>
                        <div class="block-desc">Bollinger + RSI extremes</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="template-momentum">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">Momentum Breakout</div>
                        <div class="block-desc">RSI + MACD + Stochastic</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="template-institutional">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">Institutional Flow</div>
                        <div class="block-desc">VWAP + OBV + Volume</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="template-ema-pullback">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">EMA Pullback</div>
                        <div class="block-desc">Trend + RSI pullback</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="template-atr-macd">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">ATR + MACD</div>
                        <div class="block-desc">Volatility + momentum</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="template-trendline-breakout">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">Trendline Breakout</div>
                        <div class="block-desc">Breakout + Volume + MACD</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="template-momentum-trend-breakout">
                    <div class="block-icon">🔀</div>
                    <div class="block-info">
                        <div class="block-name">Momentum Trend Breakout</div>
                        <div class="block-desc">RSI + EMA + Trendline + Volume (Scalping)</div>
                    </div>
                </div>
                </div>
            </div>

            <div class="block-category">
                <div class="category-title">Configuration</div>
                <div class="category-blocks">
                <input type="text" class="category-search" placeholder="Search config..." data-category="config">
                <div class="block-item" draggable="true" data-block-type="alpaca_config">
                    <div class="block-icon color-config">🔑</div>
                    <div class="block-info">
                        <div class="block-name">Alpaca Data</div>
                        <div class="block-desc">Symbol • Timeframe • Lookback</div>
                    </div>
                </div>
                </div>
            </div>

            <div class="block-category">
                <div class="category-title">Data Sources</div>
                <div class="category-blocks">
                <input type="text" class="category-search" placeholder="Search sources..." data-category="sources">
                <div class="block-item" draggable="true" data-block-type="input">
                    <div class="block-icon color-input">📥</div>
                    <div class="block-info">
                        <div class="block-name">Price Input</div>
                        <div class="block-desc">OHLCV data source</div>
                    </div>
                </div>
                </div>
            </div>

            <div class="block-category">
                <div class="category-title">Indicators</div>
                <div class="category-blocks">
                <input type="text" class="category-search" placeholder="Search indicators..." data-category="indicators">
                <div class="block-item" draggable="true" data-block-type="rsi">
                    <div class="block-icon color-indicator">⚡</div>
                    <div class="block-info">
                        <div class="block-name">RSI</div>
                        <div class="block-desc">Relative Strength (14)</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="ema">
                    <div class="block-icon color-indicator">⚡</div>
                    <div class="block-info">
                        <div class="block-name">EMA</div>
                        <div class="block-desc">Exponential MA (20)</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="sma">
                    <div class="block-icon color-indicator">⚡</div>
                    <div class="block-info">
                        <div class="block-name">SMA</div>
                        <div class="block-desc">Simple MA (20)</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="sma_cross">
                    <div class="block-icon color-indicator">⚡</div>
                    <div class="block-info">
                        <div class="block-name">SMA Cross</div>
                        <div class="block-desc">50/200 Golden/Death</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="macd">
                    <div class="block-icon color-indicator">⚡</div>
                    <div class="block-info">
                        <div class="block-name">MACD</div>
                        <div class="block-desc">12/26/9 momentum</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="bollinger">
                    <div class="block-icon color-indicator">⚡</div>
                    <div class="block-info">
                        <div class="block-name">Bollinger Bands</div>
                        <div class="block-desc">20 period, 2σ</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="vwap">
                    <div class="block-icon color-indicator">⚡</div>
                    <div class="block-info">
                        <div class="block-name">VWAP</div>
                        <div class="block-desc">Volume weighted avg</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="atr">
                    <div class="block-icon color-indicator">⚡</div>
                    <div class="block-info">
                        <div class="block-name">ATR</div>
                        <div class="block-desc">Volatility (14)</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="stochastic">
                    <div class="block-icon color-indicator">⚡</div>
                    <div class="block-info">
                        <div class="block-name">Stochastic</div>
                        <div class="block-desc">%K / %D oscillator</div>
                    </div>
                </div>
                </div>
            </div>

            <div class="block-category">
                <div class="category-title">Volume Analysis</div>
                <div class="category-blocks">
                <input type="text" class="category-search" placeholder="Search volume..." data-category="volume">
                <div class="block-item" draggable="true" data-block-type="obv">
                    <div class="block-icon color-volume">💧</div>
                    <div class="block-info">
                        <div class="block-name">OBV</div>
                        <div class="block-desc">On Balance Volume</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="volspike">
                    <div class="block-icon color-volume">💧</div>
                    <div class="block-info">
                        <div class="block-name">Volume Spike</div>
                        <div class="block-desc">Detect volume surges</div>
                    </div>
                </div>
                </div>
            </div>

            <div class="block-category">
                <div class="category-title">Logic</div>
                <div class="category-blocks">
                <input type="text" class="category-search" placeholder="Search logic..." data-category="logic">
                <div class="block-item" draggable="true" data-block-type="compare">
                    <div class="block-icon color-logic">➕</div>
                    <div class="block-info">
                        <div class="block-name">Compare</div>
                        <div class="block-desc">Threshold test >,<</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="and">
                    <div class="block-icon color-logic">➕</div>
                    <div class="block-info">
                        <div class="block-name">AND Gate</div>
                        <div class="block-desc">Combine signals</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="or">
                    <div class="block-icon color-logic">➕</div>
                    <div class="block-info">
                        <div class="block-name">OR Gate</div>
                        <div class="block-desc">Either signal passes</div>
                    </div>
                </div>
                <div class="block-item" draggable="true" data-block-type="not">
                    <div class="block-icon color-logic">➕</div>
                    <div class="block-info">
                        <div class="block-name">NOT Gate</div>
                        <div class="block-desc">Invert a signal</div>
                    </div>
                </div>
                </div>
            </div>

            <div class="block-category">
                <div class="category-title">AI / Assistant</div>
                <div class="category-blocks">
                <input type="text" class="category-search" placeholder="Search AI..." data-category="ai">
                <div class="block-item" draggable="true" data-block-type="ai_agent">
                    <div class="block-icon color-output">🤖</div>
                    <div class="block-info">
                        <div class="block-name">AI Agent</div>
                        <div class="block-desc">Analyze & explain strategy</div>
                    </div>
                </div>
                </div>
            </div>

            <div class="block-category">
                <div class="category-title">Output</div>
                <div class="category-blocks">
                <input type="text" class="category-search" placeholder="Search output..." data-category="output">
                <div class="block-item" draggable="true" data-block-type="signal">
                    <div class="block-icon color-output">🎯</div>
                    <div class="block-info">
                        <div class="block-name">Signal Output</div>
                        <div class="block-desc">Final strategy signal</div>
                    </div>
                </div>
                </div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container">
            <svg class="connection-layer" id="connectionLayer">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                        <polygon points="0 0, 10 3, 0 6" fill="#6e7380" />
                    </marker>
                    <linearGradient id="connectionGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#a78bfa;stop-opacity:1" />
                    </linearGradient>
                </defs>
            </svg>
            <div class="canvas" id="canvas"></div>
            
            <div class="toolbar">
                <button class="toolbar-btn" id="organizeBtn" title="Auto-arrange blocks">Organize</button>
                <button class="toolbar-btn" id="clearBtn">Clear</button>
                <button class="toolbar-btn" id="importBtn" title="Load workflow from file">Import</button>
                <button class="toolbar-btn" id="exportBtn">Export</button>
                <button class="toolbar-btn" id="backTestingBtn" title="Back Testing">Back Testing</button>
                <button class="toolbar-btn primary" id="runBtn">Run Strategy</button>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomInBtn" title="Zoom In">+</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button class="zoom-btn" id="zoomOutBtn" title="Zoom Out">−</button>
                <button class="zoom-btn" id="zoomResetBtn" title="Reset Zoom">⊙</button>
            </div>

            <!-- minimap removed -->

            <div class="status-bar">
                <div class="status-item">
                    <div class="status-dot"></div>
                    <span>Ready</span>
                </div>
                <div class="status-item">
                    <span id="nodeCount">0 blocks</span>
                </div>
                <div class="status-item">
                    <span id="connectionCount">0 connections</span>
                </div>
            </div>
        </div>

        <!-- Output Panel -->
        <div class="output-panel" id="outputPanel" style="display:none;">
            <div class="output-panel-resize-handle" id="resizeHandle"></div>
            <div class="output-header">
                <div class="output-header-top">
                    <div class="output-header-title-group">
                        <h3 id="outputHeaderTitle">Strategy Results</h3>
                        <div class="output-header-meta">
                            <span id="outputTimestamp">--</span>
                            <span id="outputHeaderBadge" class="output-status-badge completed" style="display:none;">Completed</span>
                        </div>
                    </div>
                    <div class="output-header-actions">
                        <button class="output-action-btn" id="rerunBtn" title="Re-run Workflow">
                            <span>↻</span>
                            <span>Re-run</span>
                        </button>
                        <button class="output-action-btn" id="downloadBtn" title="Download Report">
                            <span>⬇</span>
                            <span>Download</span>
                        </button>
                        <button class="output-close" id="closeOutput">×</button>
                    </div>
                </div>
                <div class="output-tabs" id="outputTabs" style="display:none;"></div>
            </div>
            <div class="output-content" id="outputContent">
                <!-- Content will be dynamically injected -->
                <div style="text-align:center; padding:60px 20px; color:#787b86;">
                    <div style="font-size:48px; margin-bottom:16px;">📊</div>
                    <div style="font-size:15px; font-weight:600; margin-bottom:8px;">No results yet</div>
                    <div style="font-size:13px;">Run your workflow to see detailed analytics</div>
                </div>
            </div>
            <div class="output-content" id="agentContent" style="display: none;">
                <div style="text-align:center; padding:60px 20px; color:#787b86;">
                    <div style="font-size:48px; margin-bottom:16px;">🤖</div>
                    <div style="font-size:15px; font-weight:600; margin-bottom:8px;">No AI analysis yet</div>
                    <div style="font-size:13px;">Add an AI Agent block to your workflow</div>
                </div>
            </div>
        </div>

        <!-- Bottom Drawer Chart Panel -->
        <div class="chart-drawer" id="chartDrawer">
            <div class="chart-drawer-header">
                <div class="chart-drawer-title">Stratigy Monitor</div>
                <div class="chart-drawer-controls">
                    <!-- Removed Live/Backtest and timeframe buttons (non-functional) -->
                    <button class="chart-drawer-btn" id="drawerExpandBtn">Expand</button>
                </div>
            </div>
            <div class="chart-drawer-body">
                <!-- Live Pulls Chart (replaces NVDA static image) -->
                <div style="margin: 12px 16px; padding: 16px; background: #0b0f14; border-radius: 8px; border: 1px solid #1f2937; position: relative;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 12px;">
                        <!-- Header and status removed as requested -->
                    </div>
                    <canvas id="drawerPullsChart" style="width: 100%; height: 260px; display:block; border-radius: 6px; border: 1px solid #1f2937;"></canvas>
                </div>
                
                <!-- Legend removed per request: Asset Price & Strategy Equity markers hidden -->
                <div class="chart-drawer-cursor" id="drawerCursor"></div>
                <div class="chart-drawer-tooltip" id="drawerTooltip">
                    <div class="chart-drawer-tooltip-row">
                        <span class="chart-drawer-tooltip-label">Time:</span>
                        <span class="chart-drawer-tooltip-value" id="tooltipTime">--</span>
                    </div>
                    <!-- Asset and Equity tooltip rows removed (legend markers hidden) -->
                </div>
                <!-- Legacy strategy/backtest canvas removed per request -->
                <div class="chart-drawer-canvas-wrapper">
                    <!-- removed: <canvas id="drawerStrategyChart"></canvas> -->
                </div>
                <!-- Compact legend / key describing chart visuals -->
                <div class="chart-drawer-legend" style="margin:8px 16px 12px 16px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
                    <div class="chart-drawer-legend-item" style="display:flex; gap:8px; align-items:center;">
                        <div style="width:12px; height:12px; background:#2962ff; border-radius:2px; box-shadow:0 0 6px rgba(41,98,255,0.15);"></div>
                        <div class="chart-drawer-legend-label">Blue line: Asset price</div>
                    </div>
                    <div class="chart-drawer-legend-item" style="display:flex; gap:8px; align-items:center;">
                        <div style="width:12px; height:12px; background:#22c55e; border-radius:50%; box-shadow:0 0 6px rgba(34,197,94,0.12);"></div>
                        <div class="chart-drawer-legend-label">Green marker: BUY (confirmed)</div>
                    </div>
                    <div class="chart-drawer-legend-item" style="display:flex; gap:8px; align-items:center;">
                        <div style="width:12px; height:12px; background:#ef4444; border-radius:50%; box-shadow:0 0 6px rgba(239,68,68,0.12);"></div>
                        <div class="chart-drawer-legend-label">Red marker: SELL (confirmed)</div>
                    </div>
                    <div class="chart-drawer-legend-item" style="display:flex; gap:8px; align-items:center;">
                        <div style="width:10px; height:10px; background:#A1A6B2; border-radius:50%;"></div>
                        <div class="chart-drawer-legend-label">Gray dot: Neutral / No signal</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Premium Results Panel -->
    <div class="results-panel" id="resultsPanel">
        <div class="results-panel-header">
            <div class="results-panel-title">
                <div class="results-panel-icon">⚡</div>
                <div>
                    Strategy Insights
                    <div class="results-section-subtitle" id="resultsPanelStatus">Ready</div>
                </div>
            </div>
            <button class="results-panel-close" onclick="toggleResultsPanel()" title="Close Panel">×</button>
        </div>
        <div class="results-panel-body">
            <!-- Price History Chart Section (Strategy Insights) -->
            <!--<div class="results-section" id="priceChartSection">
                <div class="results-section-header">
                    <div class="results-section-icon" style="background:linear-gradient(135deg,#0f172a,#1e3a8a);">📉</div>
                    <div>
                        <div class="results-section-title" id="priceChartHeader"></div>
                        <div class="results-section-subtitle">Live closing prices</div>
                    </div>
                </div>
                <div id="priceChartContainer" style="position:relative; background:#000; border:1px solid #1f2937; border-radius:8px; padding:8px; margin-top:8px;">
                    <canvas id="insightsPriceChart" style="width:100%; height:240px; display:block;"></canvas>
                    <div id="priceChartError" style="position:absolute; inset:0; display:none; align-items:center; justify-content:center; color:#ef4444; font-size:13px;">Unable to load price data.</div>
                    <div id="priceChartTooltip" style="display:none; position:absolute; pointer-events:none; background:#111827; color:#e5e7eb; padding:6px 8px; font-size:11px; border:1px solid #1f2937; border-radius:6px; box-shadow:0 4px 14px rgba(0,0,0,.6);">
                        <div id="priceChartTooltipTime" style="margin-bottom:4px; font-weight:500; color:#93c5fd;"></div>
                        <div id="priceChartTooltipPrice" style="font-family:monospace;"></div>
                    </div>
                </div>
            </div-->
            <!-- Latest Confirmed Signal Section -->
            <div class="results-section">
                <div class="results-section-header">
                    <div class="results-section-icon" style="background: linear-gradient(135deg, #1a2a2a 0%, #0f172a 100%);">🚀</div>
                    <div>
                        <div class="results-section-title">Latest Confirmed Signal</div>
                        <div class="results-section-subtitle">Most recent strategy decision</div>
                    </div>
                </div>
                <div id="latestSignalBox" class="output-section">
                    <div class="output-text" style="color:#9ca3af;">No confirmed signal yet. Run your workflow to see the latest decision here.</div>
                </div>
            </div>

            <!-- AI Strategy Analysis Section -->
            <div class="results-section">
                <div class="results-section-header">
                    <div class="results-section-icon ai">AI</div>
                    <div>
                        <div class="results-section-title">AI Strategy Analysis</div>
                        <div class="results-section-subtitle">Live workflow intelligence</div>
                    </div>
                </div>
                <div class="ai-analysis-box" id="aiAnalysisBox">
                    <div class="ai-analysis-label">
                        <div class="ai-status-dot"></div>
                        Analyzing strategy...
                    </div>
                    <div class="ai-analysis-text">
                        Run your workflow to see AI-powered insights about your strategy's behavior, trigger conditions, and potential improvements.
                    </div>
                </div>
            </div>

            <!-- Last 10 Completed Signals Section -->
            <div class="results-section">
                <div class="results-section-header">
                    <div class="results-section-icon signals">📊</div>
                    <div>
                        <div class="results-section-title">Last 10 Signals</div>
                        <div class="results-section-subtitle">Recent workflow completions</div>
                    </div>
                </div>
                <div class="signal-list" id="signalList">
                    <div class="signal-empty">
                        <div class="signal-empty-icon">📈</div>
                        <div class="signal-empty-text">
                            No signals recorded yet.<br>
                            Execute your workflow to track signals here.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="workflow_runner.js"></script>
    <script>
        // Keep last v2 results in memory for download/Rerun header controls
        window.lastPanelData = null;

        // Collapsible categories in sidebar
        (function() {
            document.querySelectorAll('.category-title').forEach(title => {
                title.addEventListener('click', () => {
                    const category = title.closest('.block-category');
                    category.classList.toggle('collapsed');
                });
            });

            // Category search functionality
            document.querySelectorAll('.category-search').forEach(searchInput => {
                searchInput.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    const categoryBlocks = e.target.closest('.category-blocks');
                    const blockItems = categoryBlocks.querySelectorAll('.block-item');
                    
                    blockItems.forEach(item => {
                        const blockName = item.querySelector('.block-name').textContent.toLowerCase();
                        const blockDesc = item.querySelector('.block-desc')?.textContent.toLowerCase() || '';
                        const blockType = item.getAttribute('data-block-type').toLowerCase();
                        
                        if (blockName.includes(searchTerm) || blockDesc.includes(searchTerm) || blockType.includes(searchTerm)) {
                            item.classList.remove('hidden');
                        } else {
                            item.classList.add('hidden');
                        }
                    });
                });
                
                // Prevent search input from being draggable
                searchInput.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                });
                
                searchInput.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
            });
        })();

        // Output panel resize logic
        (function() {
            const panel = document.getElementById('outputPanel');
            const handle = document.getElementById('resizeHandle');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            const minWidth = 380;
            const maxWidth = 1200;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = panel.offsetWidth;
                handle.classList.add('resizing');
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const deltaX = startX - e.clientX;
                const newWidth = Math.min(maxWidth, Math.max(minWidth, startWidth + deltaX));
                panel.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    handle.classList.remove('resizing');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();

        // ========== BOTTOM DRAWER CHART PANEL ==========
        (function() {
            const drawer = document.getElementById('chartDrawer');
            const handle = document.getElementById('drawerHandle');
            const expandBtn = document.getElementById('drawerExpandBtn');
            const closeBtn = document.getElementById('drawerCloseBtn');
            const liveBtn = document.getElementById('drawerLiveBtn');
            const backtestBtn = document.getElementById('drawerBacktestBtn');
            const canvas = document.getElementById('drawerStrategyChart');
            const tooltip = document.getElementById('drawerTooltip');
            const tooltipTime = document.getElementById('tooltipTime');
            const tooltipPrice = document.getElementById('tooltipPrice');
            const tooltipStrategy = document.getElementById('tooltipStrategy');
            const cursor = document.getElementById('drawerCursor');
            const timeframeBtns = Array.from(document.querySelectorAll('.timeframe-btn'));
            let selectedTimeframe = '1h';
            window.selectedTimeframe = selectedTimeframe;
            let priceHistorySeries = [];
            let priceHistoryTimestamps = [];

            let isDragging = false;
            let startY = 0;
            let startHeight = 0;
            let chartData = { prices: [], strategy: [], timestamps: [] };
            let mode = 'backtest'; // 'live' or 'backtest'
            let isExpanded = false;
            // track last known closed (compact) height so we can restore it after expand/minimize
            let lastClosedHeight = drawer ? drawer.offsetHeight : 60;
            let rafId = null;

            // Helper to update drawer expanded state UI in one place
            function updateDrawerExpandedUI() {
                if (!drawer) return;
                const header = drawer.querySelector('.chart-drawer-header');
                const body = drawer.querySelector('.chart-drawer-body');
                if (isExpanded) {
                    // Add expanded class for styling, and lift slightly to show a small top margin
                    drawer.classList.add('expanded');
                    if (expandBtn) expandBtn.textContent = 'Minimize';
                    // Compute required height: header + body content, add a small padding and keep a top margin
                    const headerH = header ? header.offsetHeight : 48;
                    const bodyScroll = body ? body.scrollHeight : (drawer.scrollHeight - headerH);
                    const topMargin = 80; // leave larger gap from top of viewport
                    const extraPadding = 12; // small visual breathing room
                    const desired = Math.min(window.innerHeight - topMargin, headerH + bodyScroll + extraPadding);
                    drawer.style.height = Math.max(120, desired) + 'px';
                    // Optionally shift a little upward by setting a bottom offset (keep bottom:0 layout)
                    // We keep bottom:0 so drawer sits at bottom; top gap comes from reduced height
                } else {
                    // Collapse to compact height
                    drawer.classList.remove('expanded');
                    if (expandBtn) expandBtn.textContent = 'Expand';
                    // restore the last known compact/closed height; fall back to current computed or 60
                    const fallback = drawer.offsetHeight || 60;
                    drawer.style.height = (lastClosedHeight || fallback || 60) + 'px';
                }
                setTimeout(() => {
                    try { renderChart(); } catch(e) {}
                    try { drawSignalHistoryChart(); } catch(e) {}
                }, 300);
            }

            // If the legacy strategy chart canvas is absent, skip strategy renderer
            if (!canvas) {
                // We replaced the NVDA/strategy chart with the live pulls chart.
                // Drawer resizing/expand still works independently; live chart re-renders via its own observer.
                if (handle) handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startHeight = drawer.offsetHeight;
                    e.preventDefault();
                });
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const deltaY = startY - e.clientY;
                    const newHeight = Math.max(40, Math.min(window.innerHeight - 60, startHeight + deltaY));
                    drawer.style.height = newHeight + 'px';
                    if (newHeight > 150) {
                        drawer.classList.add('expanded');
                    } else {
                        drawer.classList.remove('expanded');
                        // remember this as the compact/closed height
                        lastClosedHeight = newHeight;
                    }
                });
                document.addEventListener('mouseup', () => { isDragging = false; });
                if (expandBtn) expandBtn.addEventListener('click', () => { isExpanded = !isExpanded; updateDrawerExpandedUI(); });
                if (closeBtn) closeBtn.addEventListener('click', () => { isExpanded = false; drawer.style.height = (lastClosedHeight || drawer.offsetHeight || 60) + 'px'; updateDrawerExpandedUI(); });
                return;
            }

            // Drag to resize with RAF optimization (guard handle)
            if (handle) handle.addEventListener('mousedown', (e) => {
                isDragging = true;
                startY = e.clientY;
                startHeight = drawer.offsetHeight;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                // Cancel any pending animation frame
                if (rafId) cancelAnimationFrame(rafId);
                
                const deltaY = startY - e.clientY;
                const newHeight = Math.max(40, Math.min(window.innerHeight - 60, startHeight + deltaY));
                
                // Update height immediately for smooth dragging
                drawer.style.height = newHeight + 'px';
                if (newHeight > 150) {
                    drawer.classList.add('expanded');
                } else {
                    drawer.classList.remove('expanded');
                    // remember this as the compact/closed height so collapse restores it
                    lastClosedHeight = newHeight;
                }
                
                // Defer chart rendering with requestAnimationFrame
                rafId = requestAnimationFrame(() => {
                    renderChart();
                    drawSignalHistoryChart(); // Update signal history chart on resize
                    rafId = null;
                });
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    // Force final render after drag completes
                    if (rafId) cancelAnimationFrame(rafId);
                    renderChart();
                    drawSignalHistoryChart(); // Update signal history chart after drag completes
                }
            });

            // Expand/collapse buttons
            if (expandBtn) expandBtn.addEventListener('click', () => { isExpanded = !isExpanded; updateDrawerExpandedUI(); });
            if (closeBtn) closeBtn.addEventListener('click', () => { isExpanded = false; drawer.style.height = (lastClosedHeight || drawer.offsetHeight || 60) + 'px'; updateDrawerExpandedUI(); });

            // Mode toggle (Live/Backtest controls hidden). Guard existing elements if present.
            if (liveBtn) {
                liveBtn.addEventListener('click', () => { console.log('Live mode coming soon'); });
            }
            if (backtestBtn) {
                backtestBtn.addEventListener('click', () => {
                    mode = 'backtest';
                    backtestBtn.classList.add('active');
                    if (liveBtn) liveBtn.classList.remove('active');
                    // Trigger workflow execution if nodes exist
                    if (state && state.nodes && state.nodes.length > 0 && state.nodes.some(n => n.type !== 'alpaca_config')) {
                        const runBtnEl = document.getElementById('runBtn'); if (runBtnEl) runBtnEl.click();
                    }
                });
            }

            // Timeframe selection
            timeframeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    timeframeBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    // Highlight selected button
                    timeframeBtns.forEach(b => { if(!b.classList.contains('active')) b.style.background=''; });
                    btn.style.background = '#1d2532';
                    selectedTimeframe = btn.getAttribute('data-tf');
                    window.selectedTimeframe = selectedTimeframe;
                    if (window.vars) window.vars.set('timeframe', selectedTimeframe);
                    fetchPriceHistory();
                    renderInsightsPriceChart();
                });
            });

            window.getCurrentSymbol = function() {
                // Primary source: first alpaca_config node present in state
                if (window.state && Array.isArray(window.state.nodes)) {
                    const alpacaNode = window.state.nodes.find(n => n.type === 'alpaca_config');
                    if (alpacaNode) {
                        // 1. Explicit user-changed configValues
                        if (alpacaNode.configValues && alpacaNode.configValues.symbol) {
                            return String(alpacaNode.configValues.symbol).toUpperCase();
                        }
                        // 2. Legacy inline config object (sample workflows)
                        if (alpacaNode.config && alpacaNode.config.symbol) {
                            return String(alpacaNode.config.symbol).toUpperCase();
                        }
                        // 3. Definition defaults (blockDefs array config)
                        if (alpacaNode.def && Array.isArray(alpacaNode.def.config)) {
                            const symbolField = alpacaNode.def.config.find(f => f.name === 'symbol');
                            if (symbolField && symbolField.value) {
                                return String(symbolField.value).toUpperCase();
                            }
                        }
                    }
                }
                return null;
            };
            const getCurrentSymbol = window.getCurrentSymbol; // Local alias for convenience

            // Safe helper to avoid ReferenceErrors if getCurrentSymbol isn't in scope
            window.safeGetCurrentSymbol = function() {
                try {
                    if (typeof getCurrentSymbol === 'function') return getCurrentSymbol();
                    if (typeof window.getCurrentSymbol === 'function') return window.getCurrentSymbol();
                } catch (e) { /* ignore */ }
                console.warn('safeGetCurrentSymbol: getCurrentSymbol not available');
                return null;
            };

            async function fetchPriceHistory() {
                const symbol = getCurrentSymbol();
                const currentTf = window.selectedTimeframe || '1h';
                // Debug symbol detection (remove if noisy)
                if (!symbol) {
                    console.debug('[PriceChart] No symbol detected by getCurrentSymbol()');
                } else {
                    console.debug('[PriceChart] Using symbol:', symbol, 'Timeframe:', currentTf);
                }
                if (!symbol) {
                    // Show placeholder if no symbol selected
                    window.priceHistoryBars = [];
                    drawSignalHistoryChart();
                    renderInsightsPriceChart();
                    return;
                }
                
                // Get Alpaca credentials from workflow nodes
                let alpacaKeyId = '';
                let alpacaSecretKey = '';
                if (window.state && window.state.nodes) {
                    const alpacaNode = window.state.nodes.find(n => n.type === 'alpaca_config');
                    if (alpacaNode && alpacaNode.configValues) {
                        alpacaKeyId = alpacaNode.configValues.keyId || '';
                        alpacaSecretKey = alpacaNode.configValues.secretKey || '';
                    }
                }
                
                // Smooth fade out transition
                const canvas = document.getElementById('signalHistoryChart');
                if (canvas && !isChartTransitioning) {
                    isChartTransitioning = true;
                    chartTransitionOpacity = 0;
                    drawSignalHistoryChart();
                }
                
                const qs = new URLSearchParams({ 
                    symbol, 
                    timeframe: currentTf, 
                    limit: '200',
                    alpacaKeyId,
                    alpacaSecretKey
                });
                try {
                    const r = await fetch(`http://localhost:5000/price_history?${qs.toString()}`);
                    const j = await r.json();
                    if (j && j.bars && j.bars.length) {
                        window.priceHistoryBars = j.bars;
                        priceHistorySeries = j.bars.map(b => b.close);
                        priceHistoryTimestamps = j.bars.map(b => b.t);
                        window._lastPriceFetchError = null;
                        if (window.vars) {
                            const last = j.bars[j.bars.length - 1] || {};
                            window.vars.setMany({
                                bars: j.bars,
                                latestClose: typeof last.close === 'number' ? last.close : null,
                                lastMarketUpdate: new Date().toISOString()
                            });
                        }
                    } else {
                        window.priceHistoryBars = [];
                        window._lastPriceFetchError = j && j.error ? j.error : 'No data';
                    }
                } catch (e) {
                    console.warn('Failed to fetch price history', e);
                    window.priceHistoryBars = [];
                    window._lastPriceFetchError = e.message || 'Fetch failed';
                }
                
                // Smooth fade in transition
                setTimeout(() => {
                    chartTransitionOpacity = 1;
                    isChartTransitioning = false;
                    drawSignalHistoryChart();
                    renderChart();
                    renderInsightsPriceChart();
                }, 150);
            }

            // Extend updateDrawerChart to keep strategy but not overwrite selected timeframe price history
            const originalUpdateDrawerChart = window.updateDrawerChart;
            window.updateDrawerChart = function(prices, strategy, timestamps) {
                chartData = { prices, strategy, timestamps };
                renderChart();
            };

            // Override renderChart to use priceHistorySeries when available
            const originalRenderChart = renderChart;
            // Replace existing renderChart after its definition later using a setter flag
            const renderOverrideReady = () => typeof originalRenderChart === 'function';
            const applyOverride = () => {
                if (!renderOverrideReady()) return;
                renderChart = function() {
                    // Use price history for price line if loaded
                    const priceSeries = (priceHistorySeries && priceHistorySeries.length) ? priceHistorySeries : chartData.prices;
                    const timeSeries = (priceHistoryTimestamps && priceHistoryTimestamps.length === priceSeries.length) ? priceHistoryTimestamps : chartData.timestamps;
                    if (!canvas || priceSeries.length === 0) return originalRenderChart();
                    // Temporarily swap chartData.prices & timestamps, call original, then restore
                    const saved = { prices: chartData.prices, timestamps: chartData.timestamps };
                    chartData.prices = priceSeries;
                    chartData.timestamps = timeSeries;
                    originalRenderChart();
                    chartData.prices = saved.prices;
                    chartData.timestamps = saved.timestamps;
                    // Overlay label for timeframe
                    try {
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#8b5cf6';
                        ctx.font = '11px monospace';
                        ctx.textAlign = 'right';
                        const overlayTf = window.selectedTimeframe || '1h';
                        ctx.fillText(`${safeGetCurrentSymbol() || ''} ${overlayTf}`, canvas.getBoundingClientRect().width - 80, 24);
                    } catch(e) {}
                }
            };
            // Poll until originalRenderChart available (defined later in file)
            const overrideInterval = setInterval(() => {
                if (renderOverrideReady()) { applyOverride(); clearInterval(overrideInterval); }
            }, 200);

            // Initial fetch
            fetchPriceHistory();
            
            // Periodic check to load chart if symbol becomes available
            let lastCheckedSymbol = null;
            setInterval(() => {
                const currentSymbol = safeGetCurrentSymbol();
                if (currentSymbol && currentSymbol !== lastCheckedSymbol) {
                    lastCheckedSymbol = currentSymbol;
                    if (window.vars) window.vars.set('symbol', currentSymbol);
                    console.log('Chart: Detected symbol change to', currentSymbol);
                    fetchPriceHistory();
                    renderInsightsPriceChart();
                }
            }, 2000); // Check every 2 seconds
            
            // Watch for Alpaca config changes (symbol/timeframe) to auto-update chart
            setInterval(() => {
                const symbolSelect = document.querySelector('select[name="symbol"]');
                const timeframeSelect = document.querySelector('select[name="timeframe"]');
                const priceTypeSelect = document.querySelector('select[name="priceType"]');
                const daysSelect = document.querySelector('select[name="days"]');
                if (symbolSelect && symbolSelect.value) {
                    const newSymbol = symbolSelect.value.toUpperCase();
                    if (newSymbol !== window._lastChartSymbol) {
                        window._lastChartSymbol = newSymbol;
                        if (window.vars) window.vars.set('symbol', newSymbol);
                        fetchPriceHistory();
                    }
                }
                if (timeframeSelect && timeframeSelect.value) {
                    const newTf = timeframeSelect.value;
                    if (newTf !== window._lastChartTimeframe) {
                        window._lastChartTimeframe = newTf;
                        // Update selected timeframe button
                        const tfBtn = Array.from(document.querySelectorAll('.timeframe-btn')).find(b => {
                            const mapped = {'1Min':'1m','5Min':'5m','15Min':'15m','1Hour':'1h','4Hour':'4h','1Day':'1d'};
                            return mapped[newTf] === b.getAttribute('data-tf');
                        });
                        if (tfBtn) {
                            timeframeBtns.forEach(b => b.classList.remove('active'));
                            tfBtn.classList.add('active');
                            selectedTimeframe = tfBtn.getAttribute('data-tf');
                            window.selectedTimeframe = selectedTimeframe;
                            if (window.vars) window.vars.setMany({ timeframe: selectedTimeframe, timeframeRaw: newTf });
                        }
                        fetchPriceHistory();
                        renderInsightsPriceChart();
                    }
                }
                if (priceTypeSelect && priceTypeSelect.value) {
                    const pt = priceTypeSelect.value;
                    if (pt !== window._lastPriceType) {
                        window._lastPriceType = pt;
                        if (window.vars) window.vars.set('priceType', pt);
                    }
                }
                if (daysSelect && daysSelect.value) {
                    const d = daysSelect.value;
                    if (d !== window._lastLookbackDays) {
                        window._lastLookbackDays = d;
                        if (window.vars) window.vars.set('days', d);
                    }
                }
            }, 500);

            // Reactive header update for price chart
            function updatePriceChartHeader() {
                try {
                    const el = document.getElementById('priceChartHeader');
                    if (!el) return;
                    // Remove header contents per request
                    el.textContent = '';
                } catch(_){}
            }
            if (window.vars) {
                window.vars.subscribe('symbol', updatePriceChartHeader);
                window.vars.subscribe('timeframe', updatePriceChartHeader);
            }
            // Initialize header once
            updatePriceChartHeader();
            
            // Add hover interaction for premium tooltip on stock price chart
            const stockCanvas = document.getElementById('signalHistoryChart');
            if (stockCanvas) {
                stockCanvas.addEventListener('mousemove', (e) => {
                    if (!window.chartLinePoints || window.chartLinePoints.length === 0) return;
                    
                    const rect = stockCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Find nearest point
                    let nearest = null;
                    let minDist = Infinity;
                    window.chartLinePoints.forEach(pt => {
                        const dist = Math.abs(pt.x - mouseX);
                        if (dist < minDist) {
                            minDist = dist;
                            nearest = pt;
                        }
                    });
                    
                    const tooltip = document.getElementById('chartHoverTooltip');
                    if (tooltip && nearest && minDist < 30) {
                        const time = new Date(nearest.time).toLocaleString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        document.getElementById('hoverTime').textContent = time;
                        document.getElementById('hoverPrice').textContent = `$${nearest.price.toFixed(2)}`;
                        
                        tooltip.style.display = 'block';
                        tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
                        tooltip.style.top = (e.clientY - rect.top - 40) + 'px';
                    } else if (tooltip) {
                        tooltip.style.display = 'none';
                    }
                });
                
                stockCanvas.addEventListener('mouseleave', () => {
                    const tooltip = document.getElementById('chartHoverTooltip');
                    if (tooltip) tooltip.style.display = 'none';
                });
            }

            // Canvas mouse interactions (only if strategy canvas is present)
            if (canvas) {
                canvas.addEventListener('mousemove', (e) => {
                    if (chartData.prices.length === 0) return;
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const dataIndex = getDataIndexFromX(x, rect.width);
                    if (dataIndex >= 0 && dataIndex < chartData.prices.length) {
                        const price = chartData.prices[dataIndex];
                        const equity = chartData.strategy[dataIndex];
                        const time = chartData.timestamps[dataIndex];
                        
                        const priceChange = ((price - chartData.prices[0]) / chartData.prices[0] * 100).toFixed(2);
                        const equityChange = ((equity - chartData.strategy[0]) / chartData.strategy[0] * 100).toFixed(2);
                        
                        if (tooltipTime) tooltipTime.textContent = formatTimestamp(time);
                        if (tooltipPrice) tooltipPrice.textContent = '$' + price.toFixed(2) + ' (' + (priceChange >= 0 ? '+' : '') + priceChange + '%)';
                        if (tooltipStrategy) tooltipStrategy.textContent = '$' + equity.toFixed(2) + ' (' + (equityChange >= 0 ? '+' : '') + equityChange + '%)';
                        
                        tooltip.style.display = 'block';
                        tooltip.style.left = Math.min(e.clientX + 10, window.innerWidth - 200) + 'px';
                        tooltip.style.top = (e.clientY - 80) + 'px';
                        
                        cursor.style.display = 'block';
                        cursor.style.left = x + 'px';
                    }
                });

                canvas.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';
                    cursor.style.display = 'none';
                });
            }

            // Get data index from X coordinate
            function getDataIndexFromX(x, width) {
                const padding = 50;
                const chartWidth = width - padding - 20;
                const ratio = (x - padding) / chartWidth;
                return Math.floor(ratio * chartData.prices.length);
            }

            // Format timestamp
            function formatTimestamp(ts) {
                if (!ts) return '--';
                try {
                    const d = new Date(ts);
                    return d.toLocaleString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                } catch {
                    return ts;
                }
            }

            // Render chart - TradingView Strategy Tester style (throttled and optimized)
            let renderScheduled = false;
            function renderChart() {
                // If already scheduled, skip to avoid redundant renders
                if (renderScheduled) return;
                renderScheduled = true;

                requestAnimationFrame(() => {
                    renderScheduled = false;

                    if (!canvas || chartData.prices.length === 0) {
                        // skip heavy work if not ready
                        return;
                    }

                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas.getBoundingClientRect();
                    const w = rect.width;
                    const h = rect.height;

                    // Resize backing store to device pixels
                    canvas.width = Math.round(w * dpr);
                    canvas.height = Math.round(h * dpr);
                    canvas.style.width = w + 'px';
                    canvas.style.height = h + 'px';

                    const ctx = canvas.getContext('2d');
                    // Use setTransform to avoid accumulating scales
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                    // Clear with dark background
                    ctx.fillStyle = '#0d1117';
                    ctx.fillRect(0, 0, w, h);

                    const padding = { left: 65, right: 65, top: 30, bottom: 40 };
                    const chartW = w - padding.left - padding.right;
                    const chartH = h - padding.top - padding.bottom;

                    // Compute min/max with single pass to avoid expensive spread operator
                    let priceMin = Infinity, priceMax = -Infinity;
                    for (let i = 0; i < chartData.prices.length; i++) {
                        const v = chartData.prices[i];
                        if (v < priceMin) priceMin = v;
                        if (v > priceMax) priceMax = v;
                    }
                    if (!isFinite(priceMin)) { priceMin = 0; priceMax = 1; }

                    let equityMin = Infinity, equityMax = -Infinity;
                    for (let i = 0; i < chartData.strategy.length; i++) {
                        const v = chartData.strategy[i];
                        if (v < equityMin) equityMin = v;
                        if (v > equityMax) equityMax = v;
                    }
                    if (!isFinite(equityMin)) { equityMin = 0; equityMax = 1; }

                    const priceRange = priceMax - priceMin || 1;
                    const equityRange = equityMax - equityMin || 1;

                    const priceToY = (val) => padding.top + chartH - ((val - priceMin) / priceRange) * chartH;
                    const equityToY = (val) => padding.top + chartH - ((val - equityMin) / equityRange) * chartH;
                    const toX = (i) => padding.left + (i / (chartData.prices.length - 1 || 1)) * chartW;

                    // Draw grid
                    ctx.strokeStyle = '#1c2128';
                    ctx.lineWidth = 1;
                    for (let i = 0; i <= 6; i++) {
                        const y = padding.top + (i / 6) * chartH;
                        ctx.beginPath();
                        ctx.moveTo(padding.left, y);
                        ctx.lineTo(w - padding.right, y);
                        ctx.stroke();
                    }

                    // Vertical time grid
                    for (let i = 0; i <= 8; i++) {
                        const x = padding.left + (i / 8) * chartW;
                        ctx.beginPath();
                        ctx.moveTo(x, padding.top);
                        ctx.lineTo(x, h - padding.bottom);
                        ctx.stroke();
                    }

                    // Left Y-axis labels (Asset Price - Blue)
                    ctx.fillStyle = '#5e81ac';
                    ctx.font = '11px monospace';
                    ctx.textAlign = 'right';
                    for (let i = 0; i <= 6; i++) {
                        const val = priceMin + (i / 6) * (priceMax - priceMin);
                        const y = padding.top + chartH - (i / 6) * chartH;
                        ctx.fillText('$' + val.toFixed(2), padding.left - 8, y + 4);
                    }

                    // Right Y-axis labels (Strategy Equity - Green)
                    ctx.fillStyle = '#88c0d0';
                    ctx.textAlign = 'left';
                    for (let i = 0; i <= 6; i++) {
                        const val = equityMin + (i / 6) * (equityMax - equityMin);
                        const y = padding.top + chartH - (i / 6) * chartH;
                        ctx.fillText('$' + val.toFixed(0), w - padding.right + 8, y + 4);
                    }

                    // X-axis labels (Time) - sample a few points
                    ctx.fillStyle = '#787b86';
                    ctx.textAlign = 'center';
                    ctx.font = '10px monospace';
                    const tsLen = chartData.timestamps.length;
                    for (let i = 0; i <= 4; i++) {
                        const idx = Math.floor((i / 4) * (tsLen - 1));
                        const time = chartData.timestamps[idx];
                        if (time) {
                            const x = padding.left + (i / 4) * chartW;
                            const formatted = formatTimestamp(time).split(',')[0];
                            ctx.fillText(formatted, x, h - padding.bottom + 20);
                        }
                    }

                    // Asset Price line (blue) with area fill
                    ctx.strokeStyle = '#2962ff';
                    ctx.lineWidth = 2.5;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    for (let i = 0; i < chartData.prices.length; i++) {
                        const price = chartData.prices[i];
                        const x = toX(i);
                        const y = priceToY(price);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();

                    // Price area fill
                    ctx.fillStyle = 'rgba(41, 98, 255, 0.08)';
                    ctx.lineTo(toX(chartData.prices.length - 1), h - padding.bottom);
                    ctx.lineTo(toX(0), h - padding.bottom);
                    ctx.closePath();
                    ctx.fill();

                    // Strategy Equity line (green) with area fill
                    ctx.strokeStyle = '#26a69a';
                    ctx.lineWidth = 2.5;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    for (let i = 0; i < chartData.strategy.length; i++) {
                        const val = chartData.strategy[i];
                        const x = toX(i);
                        const y = equityToY(val);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();

                    // Equity area fill
                    ctx.fillStyle = 'rgba(38, 166, 154, 0.08)';
                    ctx.lineTo(toX(chartData.strategy.length - 1), h - padding.bottom);
                    ctx.lineTo(toX(0), h - padding.bottom);
                    ctx.closePath();
                    ctx.fill();
                });
            }

            // Update chart data (called from workflow execution)
            window.updateDrawerChart = function(prices, strategy, timestamps) {
                console.log('Drawer chart receiving data:', {
                    prices: prices.length,
                    strategy: strategy.length,
                    timestamps: timestamps.length
                });
                
                chartData = { prices, strategy, timestamps };
                renderChart();
                
                // Auto-expand on first data
                if (drawer.offsetHeight === 60 && prices.length > 0) {
                    drawer.classList.add('expanded');
                    setTimeout(renderChart, 300);
                }
            };

            // Clear chart
            window.clearDrawerChart = function() {
                chartData = { prices: [], strategy: [], timestamps: [] };
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#131722';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            };

            // Resize observer
            const resizeObserver = new ResizeObserver(() => {
                if (chartData.prices.length > 0) {
                    renderChart();
                }
            });
            resizeObserver.observe(canvas);

        })();

        // State management
        const state = {
            nodes: [],
            connections: [],
            nextNodeId: 1,
            draggedNode: null,
            dragOffset: { x: 0, y: 0 },
            isPanning: false,
            panStart: { x: 0, y: 0 },
            canvasOffset: { x: 0, y: 0 },
            connectingFrom: null,  // { nodeId, portName, portType }
            tempConnection: null,   // Temporary line while dragging
            zoom: 1.0,
            minZoom: 0.25,
            maxZoom: 2.0
        };

        // Global dynamic variables store (reactive)
        (function(){
            const data = Object.create(null);
            const listeners = new Map(); // key -> Set<fn>

            function notify(key, value) {
                const set = listeners.get(key);
                if (set) { set.forEach(fn => { try { fn(value, key); } catch(_){} }); }
                const any = listeners.get('*');
                if (any) { any.forEach(fn => { try { fn({ key, value }); } catch(_){} }); }
            }

            const vars = {
                set(key, value) {
                    data[key] = value;
                    notify(key, value);
                    return value;
                },
                setMany(obj) {
                    if (!obj || typeof obj !== 'object') return;
                    Object.keys(obj).forEach(k => { data[k] = obj[k]; notify(k, obj[k]); });
                },
                get(key, fallback = undefined) {
                    return Object.prototype.hasOwnProperty.call(data, key) ? data[key] : fallback;
                },
                subscribe(key, fn) {
                    if (!listeners.has(key)) listeners.set(key, new Set());
                    listeners.get(key).add(fn);
                    return () => { try { listeners.get(key).delete(fn); } catch(_){} };
                },
                unsubscribe(key, fn) {
                    const set = listeners.get(key);
                    if (set) set.delete(fn);
                },
                keys() { return Object.keys(data); },
                all() { return { ...data }; }
            };

            window.vars = vars;
        })();

        // Block definitions
        const blockDefs = {
            alpaca_config: { name: 'Alpaca Data', icon: '🔑', color: 'color-config', inputs: [], outputs: ['symbol','timeframe','days'], config: [
                { name:'symbol', type:'select', value:'SPY', options:['SPY','AAPL','MSFT','NVDA','QQQ','TSLA','AMZN','META'], label:'Symbol' },
                { name:'timeframe', type:'select', value:'1Hour', options:['1Min','5Min','15Min','1Hour','1Day'], label:'Timeframe' },
                { name:'days', type:'select', value:'7', options:['5','7','14','30','90'], label:'Lookback Days' },
                { name:'priceType', type:'select', value:'close', options:['current','open','high','low','close','hl2','hlc3','ohlc4'], label:'Price Type' },
                { name:'keyId', type:'password', value:'', label:'Alpaca Key ID' },
                { name:'secretKey', type:'password', value:'', label:'Alpaca Secret Key' }
            ] },
            input: { name: 'Price Input', icon: '📥', color: 'color-input', inputs: ['symbol', 'timeframe', 'days'], outputs: ['prices', 'volumes'] },
            rsi: { name: 'RSI', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'prices'], outputs: ['rsi', 'new single'], config: [ { name:'period', type:'number', value:14, label:'Period' }, { name:'overbought', type:'number', value:70, label:'Overbought' }, { name:'oversold', type:'number', value:30, label:'Oversold' }, { name:'condition', type:'select', value:'any', options:['any','oversold','overbought','neutral'], label:'Condition' } ] },
            ema: { name: 'EMA', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'prices'], outputs: ['ema', 'new single'], config: [ { name:'period', type:'number', value:20, label:'Period' }, { name:'priceType', type:'select', value:'close', options:['close','open','high','low','hl2','hlc3','ohlc4'], label:'Price Type' }, { name:'offset', type:'number', value:0, label:'Offset' } ] },
            sma: { name: 'SMA', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'prices'], outputs: ['sma', 'new single'], config: [ { name:'period', type:'number', value:20, label:'Period' }, { name:'priceType', type:'select', value:'close', options:['close','open','high','low','hl2','hlc3','ohlc4'], label:'Price Type' }, { name:'offset', type:'number', value:0, label:'Offset' } ] },
            sma_cross: { name: 'SMA Cross', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'prices'], outputs: ['cross', 'new single'], config: [ { name:'fast', type:'number', value:50, label:'Fast' }, { name:'slow', type:'number', value:200, label:'Slow' }, { name:'crossType', type:'select', value:'any', options:['any','bullish','bearish'], label:'Cross Type' }, { name:'confirmBars', type:'number', value:1, label:'Confirm Bars' } ] },
            macd: { name: 'MACD', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'prices'], outputs: ['macd', 'signal', 'histogram', 'new single'], config: [ { name:'fast', type:'number', value:12, label:'Fast' }, { name:'slow', type:'number', value:26, label:'Slow' }, { name:'signal', type:'number', value:9, label:'Signal' }, { name:'condition', type:'select', value:'any', options:['any','bullish_cross','bearish_cross','positive','negative'], label:'Condition' }, { name:'histThreshold', type:'number', value:0, label:'Hist Threshold' } ] },
            bollinger: { name: 'Bollinger', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'prices'], outputs: ['upper', 'middle', 'lower', 'new single'], config: [ { name:'period', type:'number', value:20, label:'Period' }, { name:'std', type:'number', value:2, label:'Std Dev' }, { name:'condition', type:'select', value:'any', options:['any','above_upper','below_lower','squeeze','expansion'], label:'Condition' }, { name:'squeezeThreshold', type:'number', value:0.05, label:'Squeeze %' } ] },
            vwap: { name: 'VWAP', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'prices', 'volumes'], outputs: ['vwap', 'new single'], config: [ { name:'useDevBands', type:'select', value:'no', options:['no','yes'], label:'Dev Bands' }, { name:'devMultiplier', type:'number', value:1, label:'Dev Multi' }, { name:'condition', type:'select', value:'any', options:['any','above','below','cross_up','cross_down'], label:'Condition' } ] },
            atr: { name: 'ATR', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'high', 'low', 'close'], outputs: ['atr', 'new single'], config: [ { name:'period', type:'number', value:14, label:'Period' }, { name:'multiplier', type:'number', value:2, label:'Multiplier' }, { name:'calcStops', type:'select', value:'no', options:['no','yes'], label:'Calc Stops' }, { name:'maType', type:'select', value:'rma', options:['rma','sma','ema'], label:'MA Type' } ] },
            stochastic: { name: 'Stochastic', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'high', 'low', 'close'], outputs: ['%K', '%D', 'new single'], config: [ { name:'period', type:'number', value:14, label:'Period' }, { name:'smoothK', type:'number', value:3, label:'Smooth K' }, { name:'smoothD', type:'number', value:3, label:'Smooth D' }, { name:'overbought', type:'number', value:80, label:'Overbought' }, { name:'oversold', type:'number', value:20, label:'Oversold' }, { name:'condition', type:'select', value:'any', options:['any','oversold','overbought','k_cross_d_up','k_cross_d_down'], label:'Condition' } ] },
            obv: { name: 'OBV', icon: '💧', color: 'color-volume', inputs: ['new single', 'prices', 'volumes'], outputs: ['obv', 'new single'], config: [ { name:'maPeriod', type:'number', value:20, label:'MA Period' }, { name:'useMA', type:'select', value:'no', options:['no','yes'], label:'Use MA' }, { name:'condition', type:'select', value:'any', options:['any','rising','falling','divergence_bull','divergence_bear'], label:'Condition' } ] },
            volspike: { name: 'Volume Spike', icon: '💧', color: 'color-volume', inputs: ['new single', 'volumes'], outputs: ['spike', 'avg', 'new single'], config: [ { name:'period', type:'number', value:20, label:'Period' }, { name:'multiplier', type:'number', value:1.5, label:'Multiplier' }, { name:'minSpike', type:'number', value:1.2, label:'Min Spike' }, { name:'detectType', type:'select', value:'spike', options:['spike','dry_up','any'], label:'Detect Type' } ] },
            trendline: { name: 'Trendline', icon: '⚡', color: 'color-indicator', inputs: ['new single', 'prices'], outputs: ['support','resistance','breakout', 'new single'], config: [ { name:'lookback', type:'number', value:100, label:'Lookback' }, { name:'numTrendlines', type:'number', value:2, label:'# Trendlines' }, { name:'pivotWindow', type:'number', value:3, label:'Pivot Win' }, { name:'tolerancePct', type:'number', value:0.5, label:'Tolerance %' }, { name:'minTouches', type:'number', value:2, label:'Min Touches' }, { name:'direction', type:'select', value:'any', options:['any','bullish','bearish'], label:'Direction' }, { name:'minStrength', type:'number', value:0, label:'Min Strength' } ] },
            compare: { name: 'Compare', icon: '➕', color: 'color-logic', inputs: ['series'], outputs: ['signal'], config: [ { name:'operator', type:'select', value:'>', options:['>','<','>=','<=','=='], label:'Operator' }, { name:'threshold', type:'number', value:0, label:'Threshold' } ] },
            and: { name: 'AND Gate', icon: '➕', color: 'color-logic', inputs: ['signal_a', 'signal_b'], outputs: ['result'] },
            or: { name: 'OR Gate', icon: '➕', color: 'color-logic', inputs: ['signal_a', 'signal_b'], outputs: ['result'] },
            not: { name: 'NOT Gate', icon: '➕', color: 'color-logic', inputs: ['signal'], outputs: ['result'] },
            signal: { name: 'Signal Output', icon: '🔔', color: 'color-output', inputs: ['signal'], outputs: [] },
            ai_agent: { name: 'AI Agent', icon: '🤖', color: 'color-output', inputs: ['analyse'], outputs: ['signal'], config: [
                { name:'provider', type:'select', value:'openai', options:['openai','gemini'], label:'Provider' },
                { name:'apiKey', type:'password', value:'', label:'API Key' },
                { name:'model', type:'select', value:'gpt-4o-mini', options:['gpt-4o-mini','gpt-4o','gpt-3.5-turbo-0125','gemini-2.5-flash-lite','gemini-flash-lite-latest','gemini-flash-latest','gemini-2.5-flash','gemini-pro-latest'], label:'Model' },
                { name:'script', type:'textarea', value:'Prompt for AI Agent Block (Strategy Analysis + Formatting)\n\nYou are an analytical module that receives a continuous stream of market data, workflow settings, indicator parameters, user-selected options, and backtest outputs. Treat this input as the complete information environment for evaluating a trading strategy. Although the data may seem heterogeneous, interpret it as a unified representation of the strategy\u2019s current state.\n\nYour task is to\n\u2022 examine the data for structural coherence and potential trading signals,\n\u2022 identify patterns that may have probabilistic significance rather than assuming any deterministic relationships,\n\u2022 evaluate whether the user\u2019s indicator parameters interact sensibly with the incoming price series, volume data, and market metadata,\n\u2022 detect contradictions, missing values, or anomalies that might require user attention,\n\u2022 articulate both strengths and vulnerabilities in the strategy\u2019s logic, and\n\u2022 comment on any risks that emerge from timing mismatches, overly sensitive thresholds, or unrealistic assumptions.\n\nWhen producing output, use a consistent structure that helps traders interpret the results easily:\n\nSignal Summary\nBriefly outline potential buy or sell signals, but frame them as probabilistic tendencies tied to the supplied data.\n\nIndicator Interactions\nExplain how the user\u2019s parameters shaped the signals, noting where different indicators reinforce or counteract each other.\n\nMarket Context Observations\nHighlight contextual features from the data (trend regime, volatility environment, unusual volume patterns) that may influence strategy behavior.\n\nPerformance Notes\nIf backtest information is present, interpret it cautiously and point out issues such as overfitting, inconsistent time windows, or abrupt parameter changes.\n\nSuggestions\nOffer adjustments or refinements to indicator settings, but avoid prescriptive certainty. Present alternatives as contingent possibilities.\n\nFormatted Output\nReturn final results in this structure:\n\n{\n  "signals": [ ... ],\n  "indicator_analysis": [ ... ],\n  "contextual_factors": [ ... ],\n  "performance_insights": [ ... ],\n  "suggestions": [ ... ]\n}\n\nEnsure your analysis remains internally consistent with the data you receive, and never invent missing numerical values.', label:'Base Script' },
                { name:'comments', type:'textarea', value:'', label:'User Comments / Notes' },
                { name:'temperature', type:'number', value:0.7, label:'Temperature' },
                { name:'maxTokens', type:'number', value:512, label:'Max Tokens' }
            ] }
            ,
            note: { name: 'Text Note', icon: '📝', color: 'color-note', inputs: [], outputs: [], config: [] }
        };

        // DOM elements
        const canvas = document.getElementById('canvas');
        const connectionLayer = document.getElementById('connectionLayer');
        const nodeCountEl = document.getElementById('nodeCount');
        const connectionCountEl = document.getElementById('connectionCount');
        const outputPanel = document.getElementById('outputPanel');
        const outputContent = document.getElementById('outputContent');
        const canvasContainer = document.querySelector('.canvas-container');
        const zoomLevelEl = document.getElementById('zoomLevel');

        // Update zoom display
        function updateZoomDisplay() {
            zoomLevelEl.textContent = Math.round(state.zoom * 100) + '%';
            const transform = `translate(${state.canvasOffset.x}px, ${state.canvasOffset.y}px) scale(${state.zoom})`;
            canvas.style.transform = transform;
            // connectionLayer stays in screen space, not transformed
        }

        // Zoom in
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            state.zoom = Math.min(state.maxZoom, state.zoom + 0.1);
            updateZoomDisplay();
            renderConnections();
        });

        // Zoom out
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            state.zoom = Math.max(state.minZoom, state.zoom - 0.1);
            updateZoomDisplay();
            renderConnections();
        });

        // Reset zoom
        document.getElementById('zoomResetBtn').addEventListener('click', () => {
            state.zoom = 1.0;
            updateZoomDisplay();
            renderConnections();
        });

        // Mouse wheel zoom
        canvasContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                state.zoom = Math.max(state.minZoom, Math.min(state.maxZoom, state.zoom + delta));
                updateZoomDisplay();
                renderConnections();
            }
        }, { passive: false });

        // Tab switching for output panel
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('output-tab')) {
                const tab = e.target.dataset.tab;
                // Update active tab
                document.querySelectorAll('.output-tab').forEach(t => t.classList.remove('active'));
                e.target.classList.add('active');
                // Show/hide content
                document.getElementById('outputContent').style.display = tab === 'results' ? 'block' : 'none';
                document.getElementById('agentContent').style.display = tab === 'agent' ? 'block' : 'none';
            }
        });

        // Close output panel
        document.getElementById('closeOutput').addEventListener('click', () => {
            outputPanel.classList.remove('open');
            // Reset all workflow execution states when closing output
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('node-passed', 'node-failed', 'node-skipped', 'executing');
            });
        });

        // Organize workflow with auto-layout
        document.getElementById('organizeBtn').addEventListener('click', () => {
            if (state.nodes.length === 0) {
                return;
            }

            // Build dependency graph
            const nodeMap = new Map();
            state.nodes.forEach(n => nodeMap.set(n.id, { node: n, children: [], level: -1 }));

            // Determine parent-child relationships
            state.connections.forEach(conn => {
                const parent = nodeMap.get(conn.from.nodeId);
                const child = nodeMap.get(conn.to.nodeId);
                if (parent && child) {
                    parent.children.push(child);
                }
            });

            // Find root nodes (no incoming connections)
            const roots = [];
            state.nodes.forEach(n => {
                const hasIncoming = state.connections.some(c => c.to.nodeId === n.id);
                if (!hasIncoming) {
                    roots.push(nodeMap.get(n.id));
                }
            });

            // Assign levels using BFS
            const queue = roots.map(r => ({ node: r, level: 0 }));
            while (queue.length > 0) {
                const { node: current, level } = queue.shift();
                if (current.level < level) {
                    current.level = level;
                }
                current.children.forEach(child => {
                    queue.push({ node: child, level: level + 1 });
                });
            }

            // Handle orphaned nodes
            nodeMap.forEach(data => {
                if (data.level === -1) data.level = 0;
            });

            // Group by level
            const levels = new Map();
            nodeMap.forEach(data => {
                if (!levels.has(data.level)) {
                    levels.set(data.level, []);
                }
                levels.get(data.level).push(data.node);
            });

            // Layout parameters
            const levelWidth = 350;
            const nodeHeight = 120;
            const startX = 100;
            const startY = 100;

            // Position nodes
            levels.forEach((nodesInLevel, level) => {
                const x = startX + level * levelWidth;
                nodesInLevel.forEach((n, index) => {
                    const y = startY + index * nodeHeight;
                    n.x = x;
                    n.y = y;
                    const nodeEl = document.getElementById(`node-${n.id}`);
                    if (nodeEl) {
                        nodeEl.style.left = `${x}px`;
                        nodeEl.style.top = `${y}px`;
                    }
                });
            });

            renderConnections();
        });

        // Back Testing button (placeholder action)
        const backBtnEl = document.getElementById('backTestingBtn');
        if (backBtnEl) {
            backBtnEl.addEventListener('click', () => {
                outputPanel.classList.add('open');
                outputContent.innerHTML = `
                    <div class="output-section">
                        <h4>🔁 Back Testing</h4>
                        <p class="output-text" style="color: #9ca3af;">Backtesting started (use Run Strategy to execute live monitoring). Results will appear here.</p>
                    </div>
                `;
            });
        }

        // Drag and drop from sidebar
        document.querySelectorAll('.block-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('blockType', item.dataset.blockType);
            });
        });

        canvas.addEventListener('dragover', (e) => e.preventDefault());
        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const blockType = e.dataTransfer.getData('blockType');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (blockType) {
                // Handle dragged text notes created from settings textarea
                if (blockType === 'text_note') {
                    try {
                        const payload = e.dataTransfer.getData('text/plain');
                        const parsed = payload ? JSON.parse(payload) : { content: '', bg: '#131722' };
                        createNode('note', x, y, { content: parsed.content || '', bg: parsed.bg || '#131722' });
                    } catch (err) {
                        console.warn('Failed to parse dragged note payload', err);
                        createNode('note', x, y, { content: '', bg: '#131722' });
                    }
                    return;
                }

                // Check if it's a template
                if (blockType.startsWith('template-')) {
                    loadTemplate(blockType, x, y);
                } else {
                    createNode(blockType, x, y);
                }
            }
        });

        // Template definitions
        const templates = {
            'template-rsi-volume': {
                name: 'RSI + Volume Spike Strategy',
                description: 'Detects oversold conditions with volume confirmation',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'SPY', timeframe:'1Hour', days:'7' } },
                    { type: 'input', x: 260, y: 60 },
                    { type: 'rsi', x: 520, y: 0 },
                    { type: 'volspike', x: 520, y: 120 },
                    { type: 'and', x: 780, y: 60 },
                    { type: 'ai_agent', x: 1040, y: 60 },
                    { type: 'signal', x: 1300, y: 60 }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'symbol' },
                    { from: 0, fromPort: 'timeframe', to: 1, toPort: 'timeframe' },
                    { from: 0, fromPort: 'days', to: 1, toPort: 'days' },
                    { from: 1, fromPort: 'prices', to: 2, toPort: 'prices' },
                    { from: 1, fromPort: 'volumes', to: 3, toPort: 'volumes' },
                    { from: 2, fromPort: 'rsi', to: 4, toPort: 'signal_a' },
                    { from: 3, fromPort: 'spike', to: 4, toPort: 'signal_b' },
                    { from: 4, fromPort: 'result', to: 5, toPort: 'analyse' },
                    { from: 5, fromPort: 'signal', to: 6, toPort: 'signal' }
                ]
            },
            'template-trend-following': {
                name: 'Trend Following Strategy',
                description: 'EMA crossover with MACD momentum confirmation',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'SPY', timeframe:'1Hour', days:'14' } },
                    { type: 'input', x: 240, y: 80 },
                    { type: 'ema', x: 480, y: 20 },
                    { type: 'macd', x: 480, y: 140 },
                    { type: 'ai_agent', x: 720, y: 80 },
                    { type: 'signal', x: 960, y: 80 }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'symbol' },
                    { from: 0, fromPort: 'timeframe', to: 1, toPort: 'timeframe' },
                    { from: 0, fromPort: 'days', to: 1, toPort: 'days' },
                    { from: 1, fromPort: 'prices', to: 2, toPort: 'prices' },
                    { from: 1, fromPort: 'prices', to: 3, toPort: 'prices' },
                    { from: 2, fromPort: 'ema', to: 4, toPort: 'analyse' },
                    { from: 3, fromPort: 'histogram', to: 4, toPort: 'analyse' },
                    { from: 4, fromPort: 'signal', to: 5, toPort: 'signal' }
                ]
            },
            'template-golden-cross': {
                name: 'Golden Cross Strategy',
                description: '50/200 SMA crossover trend signal',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'SPY', timeframe:'1Day', days:'200' } },
                    { type: 'input', x: 240, y: 80 },
                    { type: 'sma_cross', x: 480, y: 80 },
                    { type: 'ai_agent', x: 720, y: 80 },
                    { type: 'signal', x: 960, y: 80 }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'symbol' },
                    { from: 0, fromPort: 'timeframe', to: 1, toPort: 'timeframe' },
                    { from: 0, fromPort: 'days', to: 1, toPort: 'days' },
                    { from: 1, fromPort: 'prices', to: 2, toPort: 'prices' },
                    { from: 2, fromPort: 'cross', to: 3, toPort: 'analyse' },
                    { from: 3, fromPort: 'signal', to: 4, toPort: 'signal' }
                ]
            },
            'template-ema-pullback': {
                name: 'EMA Pullback Strategy',
                description: 'Trend with RSI pullback entry',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'AAPL', timeframe:'1Hour', days:'10' } },
                    { type: 'input', x: 240, y: 60 },
                    { type: 'ema', x: 480, y: 0 },
                    { type: 'rsi', x: 480, y: 120 },
                    { type: 'and', x: 720, y: 60 },
                    { type: 'ai_agent', x: 960, y: 60 },
                    { type: 'signal', x: 1200, y: 60 }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'symbol' },
                    { from: 0, fromPort: 'timeframe', to: 1, toPort: 'timeframe' },
                    { from: 0, fromPort: 'days', to: 1, toPort: 'days' },
                    { from: 1, fromPort: 'prices', to: 2, toPort: 'prices' },
                    { from: 1, fromPort: 'prices', to: 3, toPort: 'prices' },
                    { from: 2, fromPort: 'ema', to: 4, toPort: 'signal_a' },
                    { from: 3, fromPort: 'rsi', to: 4, toPort: 'signal_b' },
                    { from: 4, fromPort: 'result', to: 5, toPort: 'analyse' },
                    { from: 5, fromPort: 'signal', to: 6, toPort: 'signal' }
                ]
            },
            'template-atr-macd': {
                name: 'ATR + MACD Momentum',
                description: 'Volatility filter with momentum',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'MSFT', timeframe:'1Hour', days:'14' } },
                    { type: 'input', x: 240, y: 60 },
                    { type: 'atr', x: 480, y: 0 },
                    { type: 'macd', x: 480, y: 120 },
                    { type: 'ai_agent', x: 720, y: 60 },
                    { type: 'signal', x: 960, y: 60 }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'symbol' },
                    { from: 0, fromPort: 'timeframe', to: 1, toPort: 'timeframe' },
                    { from: 0, fromPort: 'days', to: 1, toPort: 'days' },
                    { from: 1, fromPort: 'prices', to: 2, toPort: 'close' },
                    { from: 1, fromPort: 'prices', to: 3, toPort: 'prices' },
                    { from: 2, fromPort: 'atr', to: 4, toPort: 'analyse' },
                    { from: 3, fromPort: 'histogram', to: 4, toPort: 'analyse' },
                    { from: 4, fromPort: 'signal', to: 5, toPort: 'signal' }
                ]
            },
            'template-mean-reversion': {
                name: 'Mean Reversion Strategy',
                description: 'Bollinger Bands with RSI extreme levels',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'SPY', timeframe:'15Min', days:'5' } },
                    { type: 'input', x: 240, y: 60 },
                    { type: 'bollinger', x: 480, y: 0 },
                    { type: 'rsi', x: 480, y: 120 },
                    { type: 'ai_agent', x: 720, y: 60 },
                    { type: 'signal', x: 960, y: 60 }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'symbol' },
                    { from: 0, fromPort: 'timeframe', to: 1, toPort: 'timeframe' },
                    { from: 0, fromPort: 'days', to: 1, toPort: 'days' },
                    { from: 1, fromPort: 'prices', to: 2, toPort: 'prices' },
                    { from: 1, fromPort: 'prices', to: 3, toPort: 'prices' },
                    { from: 2, fromPort: 'upper', to: 4, toPort: 'analyse' },
                    { from: 3, fromPort: 'rsi', to: 4, toPort: 'analyse' },
                    { from: 4, fromPort: 'signal', to: 5, toPort: 'signal' }
                ]
            },
            'template-momentum': {
                name: 'Momentum Breakout Strategy',
                description: 'Triple confirmation: RSI, MACD, Stochastic',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'AAPL', timeframe:'1Hour', days:'10' } },
                    { type: 'input', x: 240, y: 120 },
                    { type: 'rsi', x: 480, y: 0 },
                    { type: 'macd', x: 480, y: 120 },
                    { type: 'stochastic', x: 480, y: 240 },
                    { type: 'ai_agent', x: 720, y: 120 },
                    { type: 'signal', x: 960, y: 120 }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'symbol' },
                    { from: 0, fromPort: 'timeframe', to: 1, toPort: 'timeframe' },
                    { from: 0, fromPort: 'days', to: 1, toPort: 'days' },
                    { from: 1, fromPort: 'prices', to: 2, toPort: 'prices' },
                    { from: 1, fromPort: 'prices', to: 3, toPort: 'prices' },
                    { from: 1, fromPort: 'prices', to: 4, toPort: 'close' },
                    { from: 2, fromPort: 'rsi', to: 5, toPort: 'analyse' },
                    { from: 3, fromPort: 'histogram', to: 5, toPort: 'analyse' },
                    { from: 4, fromPort: '%K', to: 5, toPort: 'analyse' },
                    { from: 5, fromPort: 'signal', to: 6, toPort: 'signal' }
                ]
            },
            'template-institutional': {
                name: 'Institutional Flow Strategy',
                description: 'VWAP, OBV, and Volume analysis',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'SPY', timeframe:'1Day', days:'30' } },
                    { type: 'input', x: 240, y: 120 },
                    { type: 'vwap', x: 480, y: 0 },
                    { type: 'obv', x: 480, y: 120 },
                    { type: 'volspike', x: 480, y: 240 },
                    { type: 'ai_agent', x: 720, y: 120 },
                    { type: 'signal', x: 960, y: 120 }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'symbol' },
                    { from: 0, fromPort: 'timeframe', to: 1, toPort: 'timeframe' },
                    { from: 0, fromPort: 'days', to: 1, toPort: 'days' },
                    { from: 1, fromPort: 'prices', to: 2, toPort: 'prices' },
                    { from: 1, fromPort: 'volumes', to: 2, toPort: 'volumes' },
                    { from: 1, fromPort: 'prices', to: 3, toPort: 'prices' },
                    { from: 1, fromPort: 'volumes', to: 3, toPort: 'volumes' },
                    { from: 1, fromPort: 'volumes', to: 4, toPort: 'volumes' },
                    { from: 2, fromPort: 'vwap', to: 5, toPort: 'analyse' },
                    { from: 3, fromPort: 'obv', to: 5, toPort: 'analyse' },
                    { from: 4, fromPort: 'spike', to: 5, toPort: 'analyse' },
                    { from: 5, fromPort: 'signal', to: 6, toPort: 'signal' }
                ]
            },
            'template-trendline-breakout': {
                name: 'Trendline Breakout Strategy',
                description: 'Trendline breakout + volume + MACD momentum confirmation',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'SPY', timeframe:'1Hour', days:'10' } },
                    { type: 'input', x: 240, y: 130 },
                    { type: 'trendline', x: 480, y: 0 },
                    { type: 'volspike', x: 480, y: 130 },
                    { type: 'macd', x: 480, y: 260 },
                    { type: 'and', x: 720, y: 65 },
                    { type: 'and', x: 960, y: 65 },
                    { type: 'ai_agent', x: 1200, y: 65 },
                    { type: 'signal', x: 1440, y: 65 }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'symbol' },
                    { from: 0, fromPort: 'timeframe', to: 1, toPort: 'timeframe' },
                    { from: 0, fromPort: 'days', to: 1, toPort: 'days' },
                    { from: 1, fromPort: 'prices', to: 2, toPort: 'prices' },
                    { from: 1, fromPort: 'volumes', to: 3, toPort: 'volumes' },
                    { from: 1, fromPort: 'prices', to: 4, toPort: 'prices' },
                    { from: 2, fromPort: 'breakout', to: 5, toPort: 'signal_a' },
                    { from: 3, fromPort: 'spike', to: 5, toPort: 'signal_b' },
                    { from: 5, fromPort: 'result', to: 6, toPort: 'signal_a' },
                    { from: 4, fromPort: 'histogram', to: 6, toPort: 'signal_b' },
                    { from: 6, fromPort: 'result', to: 7, toPort: 'analyse' },
                    { from: 7, fromPort: 'signal', to: 8, toPort: 'signal' }
                ]
            },
            'template-momentum-trend-breakout': {
                name: 'Momentum Trend Breakout',
                description: 'RSI oversold + EMA trend + Trendline breakout + Volume spike (4-way scalping)',
                nodes: [
                    { type: 'alpaca_config', x: 0, y: 0, config: { symbol:'TSLA', timeframe:'5Min', days:'20', keyId:'', secretKey:'' } },
                    { type: 'rsi', x: 0, y: 140, config: { period:14, overbought:70, oversold:30, condition:'oversold' } },
                    { type: 'ema', x: 0, y: 280, config: { period:20, priceType:'close', offset:0 } },
                    { type: 'trendline', x: 0, y: 420, config: { lookback:50, pivotWindow:5, tolerancePct:2.0, minTouches:2, numTrendlines:2, direction:'any', minStrength:0 } },
                    { type: 'volspike', x: 0, y: 560, config: { period:20, multiplier:1.5, minSpike:1.0, detectType:'spike' } },
                    { type: 'and', x: 350, y: 340, config: {} },
                    { type: 'ai_agent', x: 650, y: 340, config: { provider:'gemini', model:'gemini-2.5-flash-lite', apiKey:'', temperature:0.7, maxTokens:500, script:'Analyze this momentum breakout: RSI oversold + EMA trend + Trendline breakout + Volume spike. Check confluence and provide BUY/SELL/HOLD with reasoning.', comments:'Multi-confirmation scalping for volatile stocks' } },
                    { type: 'signal', x: 950, y: 340, config: {} }
                ],
                connections: [
                    { from: 0, fromPort: 'symbol', to: 1, toPort: 'new single' },
                    { from: 0, fromPort: 'symbol', to: 2, toPort: 'new single' },
                    { from: 0, fromPort: 'symbol', to: 3, toPort: 'new single' },
                    { from: 0, fromPort: 'days', to: 4, toPort: 'new single' },
                    { from: 1, fromPort: 'new single', to: 5, toPort: 'signal_a' },
                    { from: 2, fromPort: 'new single', to: 5, toPort: 'signal_b' },
                    { from: 3, fromPort: 'new single', to: 5, toPort: 'signal_a' },
                    { from: 4, fromPort: 'new single', to: 5, toPort: 'signal_b' },
                    { from: 5, fromPort: 'result', to: 6, toPort: 'analyse' },
                    { from: 6, fromPort: 'signal', to: 7, toPort: 'signal' }
                ]
            }
        };

        // Load template
        function loadTemplate(templateId, baseX, baseY) {
            const template = templates[templateId];
            if (!template) return;

            // Clear existing nodes
            if (state.nodes.length > 0) {
                state.nodes = [];
                state.connections = [];
                canvas.innerHTML = '';
                connectionLayer.innerHTML = '';
            }

            // Create nodes
            const nodeMap = {};
            template.nodes.forEach((nodeDef, index) => {
                const node = {
                    id: state.nextNodeId++,
                    type: nodeDef.type,
                    x: baseX + nodeDef.x,
                    y: baseY + nodeDef.y,
                    def: blockDefs[nodeDef.type]
                };
                
                if (nodeDef.config) {
                    node.configValue = nodeDef.config;
                }
                
                state.nodes.push(node);
                nodeMap[index] = node.id;
                renderNode(node);
            });

            // Create connections
            template.connections.forEach(conn => {
                const fromNodeId = nodeMap[conn.from];
                const toNodeId = nodeMap[conn.to];
                createConnection(fromNodeId, conn.fromPort, toNodeId, conn.toPort);
            });

            updateStatus();
            updatePortStyles();
        }

        // Create node
        function createNode(type, x, y, opts) {
            const def = blockDefs[type];
            const node = {
                id: state.nextNodeId++,
                type,
                x: x - 100,
                y: y - 50,
                def,
                autoOpen: true // flag to auto-open settings panel on creation
            };
            // Optional content/UI styles for 'note' and similar nodes
            if (opts) {
                if (opts.content) node.content = opts.content;
                if (opts.bg) node.uiStyles = node.uiStyles || {};
                if (opts.bg) node.uiStyles._default = { background: opts.bg };
            }
            state.nodes.push(node);
            renderNode(node);
            updateStatus();
        }

        // Render node
        function renderNode(node) {
            const nodeEl = document.createElement('div');
            nodeEl.className = 'node';
            nodeEl.id = `node-${node.id}`;
            nodeEl.style.left = `${node.x}px`;
            nodeEl.style.top = `${node.y}px`;

            let inputsHTML = node.def.inputs.map(inp => 
                `<div class="node-port input" data-port="${inp}" data-node-id="${node.id}" data-port-type="input">
                    <span class="port-dot" data-port="${inp}" data-node-id="${node.id}" data-port-type="input"></span>
                    <span>${inp}</span>
                </div>`
            ).join('');

            let outputsHTML = node.def.outputs.map(out => 
                `<div class="node-port output" data-port="${out}" data-node-id="${node.id}" data-port-type="output">
                    <span>${out}</span>
                    <span class="port-dot" data-port="${out}" data-node-id="${node.id}" data-port-type="output"></span>
                </div>`
            ).join('');

            // Inline config for SIMPLE config blocks only (symbol, timeframe, lookback)
            let configHTML = '';
            if (['symbol','timeframe','lookback'].includes(node.type) && node.def.config && !Array.isArray(node.def.config)) {
                const cfg = node.def.config;
                const val = node.configValue || cfg.value;
                if (cfg.type === 'select') {
                    const options = cfg.options.map(opt => `<option value="${opt}" ${val === opt ? 'selected' : ''}>${opt}</option>`).join('');
                    configHTML = `
                        <div style="margin-top:6px;">
                            <select class="config-select" style="padding:4px 6px;font-size:11px;" onchange="updateNodeConfig(${node.id}, this.value)">
                                ${options}
                            </select>
                        </div>`;
                } else {
                    configHTML = `
                        <div style="margin-top:6px;">
                            <input type='${cfg.type}' class='config-input' style='padding:4px 6px;font-size:11px;' value='${val}' onchange="updateNodeConfig(${node.id}, this.value)" />
                        </div>`;
                }
            }

            // For alpaca_config blocks, show the current ticker symbol at the bottom
            let tickerDisplayHTML = '';
            if (node.type === 'alpaca_config') {
                const symbol = (node.configValues && node.configValues.symbol) || 'SPY';
                tickerDisplayHTML = `
                    <div style="margin-top:8px; padding:6px 8px; background:#131722; border:1px solid #2a2e39; border-radius:4px; text-align:center;">
                        <span style="font-size:13px; font-weight:600; color:#2962ff; letter-spacing:0.5px;">${symbol}</span>
                    </div>
                `;
            }

            // For note blocks, render the note content with optional background
            let noteContentHTML = '';
            if (node.type === 'note') {
                const content = node.content ? String(node.content).replace(/</g,'&lt;').replace(/>/g,'&gt;') : '';
                const bg = (node.uiStyles && node.uiStyles._default && node.uiStyles._default.background) ? node.uiStyles._default.background : '#131722';
                noteContentHTML = `
                    <div style="margin-top:8px; padding:10px; background:${bg}; border:1px solid #2a2e39; border-radius:6px; color:#d1d4dc; font-size:13px; line-height:1.4;">
                        ${content.split('\n').map(l=>`<div>${l}</div>`).join('')}
                    </div>
                `;
            }

            // Determine if block has settings (array config or non-inline single config)
            const hasSettings = (node.def.config && Array.isArray(node.def.config)) || 
                                (node.def.config && !Array.isArray(node.def.config) && !['symbol','timeframe','lookback'].includes(node.type));
            
            const settingsBtn = hasSettings ? 
                `<button title="Settings" class="node-delete" style="font-size:14px; padding:0 6px;" onclick="openSettingsPanel(${node.id}); event.stopPropagation();">⚙</button>` : '';

            nodeEl.innerHTML = `
                <div class="node-header">
                    <div class="node-icon ${node.def.color}">${node.def.icon}</div>
                    <div class="node-title">${node.def.name}</div>
                    <div style="margin-left:auto; display:flex; gap:4px;">
                        ${settingsBtn}
                        <button class="node-delete" onclick="deleteNode(${node.id})">×</button>
                    </div>
                </div>
                <div class="node-body">
                    <div class="node-inputs">
                        ${inputsHTML}
                        ${configHTML}
                        ${tickerDisplayHTML}
                        ${noteContentHTML}
                    </div>
                    <div class="node-outputs">
                        ${outputsHTML}
                    </div>
                </div>
            `;

            nodeEl.addEventListener('mousedown', (e) => {
                if (e.target.closest('.node-delete')) return;
                if (state.isPanning) return;
                state.draggedNode = node;
                state.dragOffset = {
                    x: e.clientX - node.x * state.zoom,
                    y: e.clientY - node.y * state.zoom
                };
                nodeEl.classList.add('selected');
                canvas.classList.add('dragging-node');
            });

            canvas.appendChild(nodeEl);

            // Add port click handlers
            nodeEl.querySelectorAll('.port-dot').forEach(dot => {
                dot.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    handlePortClick(dot);
                });
            });

            // Auto-open settings panel for newly created nodes that have settings
            if (node.autoOpen) {
                const hasSettings = (node.def.config && Array.isArray(node.def.config)) || 
                                    (node.def.config && !Array.isArray(node.def.config) && !['symbol','timeframe','lookback'].includes(node.type));
                if (hasSettings && typeof window.openSettingsPanel === 'function') {
                    setTimeout(() => window.openSettingsPanel(node.id), 0);
                }
                node.autoOpen = false; // consume flag
            }
        }

        // Settings side panel (Properties Panel)
        const settingsPanel = document.createElement('div');
        settingsPanel.id = 'settingsPanel';
        settingsPanel.style.position = 'fixed';
        settingsPanel.style.top = '0';
        settingsPanel.style.right = '0';
        settingsPanel.style.width = '320px';
        settingsPanel.style.height = '100%';
        settingsPanel.style.background = '#1e222d';
        settingsPanel.style.borderLeft = '1px solid #2a2e39';
        settingsPanel.style.boxShadow = '-2px 0 8px rgba(0,0,0,0.3)';
        settingsPanel.style.transform = 'translateX(100%)';
        settingsPanel.style.transition = 'transform .2s ease';
        settingsPanel.style.zIndex = '2000';
        settingsPanel.style.display = 'flex';
        settingsPanel.style.flexDirection = 'column';
        settingsPanel.style.fontFamily = 'Inter, sans-serif';
        settingsPanel.innerHTML = `
            <div style="padding:10px 14px; display:flex; align-items:center; gap:8px; border-bottom:1px solid #2a2e39; background:#131722;">
                <div id="settingsTitle" style="font-weight:600; color:#f8f9fa; font-size:12px; letter-spacing:-0.1px;">Properties</div>
                <button onclick="closeSettingsPanel()" style="margin-left:auto; background:transparent; border:1px solid #2a2e39; color:#787b86; cursor:pointer; padding:4px 10px; border-radius:4px; font-size:11px; transition:all 0.15s;" onmouseover="this.style.borderColor='#2962ff'; this.style.color='#f8f9fa'" onmouseout="this.style.borderColor='#2a2e39'; this.style.color='#787b86'">Close</button>
            </div>
            <div id="settingsContent" style="flex:1; overflow-y:auto; padding:14px;">
            </div>
            <div id="settingsFooter" style="padding:10px 14px; border-top:1px solid #2a2e39; display:none; gap:8px; align-items:center; background:#131722;">
                <button id="settingsSaveBtn" class="toolbar-btn primary" style="margin-left:auto;">Save Changes</button>
                <button id="settingsDiscardBtn" class="toolbar-btn" style="background:transparent;">Discard</button>
            </div>
        `;
        document.body.appendChild(settingsPanel);

        window.openSettingsPanel = function(nodeId){
            const node = state.nodes.find(n=>n.id===nodeId);
            if(!node) return;
            const content = document.getElementById('settingsContent');
            const title = document.getElementById('settingsTitle');
            title.textContent = `${node.def.name}`;
            let html = '';
            // show ID & type
            html += `<div style='font-size:10px; color:#787b86; margin-bottom:16px; padding-bottom:12px; border-bottom:1px solid #2a2e39;'>ID: ${node.id} <span style='opacity:0.6'>•</span> ${node.type}</div>`;
            // Build fields
            if (Array.isArray(node.def.config)) {
                if (!node.configValues) node.configValues = {};
                node.def.config.forEach(field => {
                    const val = node.configValues[field.name] !== undefined ? node.configValues[field.name] : field.value;
                    if (field.type === 'select') {
                        const opts = field.options.map(o=>`<option value='${o}' ${val===o?'selected':''}>${o}</option>`).join('');
                        html += `
                            <div style='margin-bottom:14px;'>
                                <label style='display:block;font-size:10px;color:#787b86;margin-bottom:6px;font-weight:500;text-transform:uppercase;letter-spacing:0.5px;'>${field.label}</label>
                                <select style='width:100%;background:#131722;border:1px solid #2a2e39;color:#d1d4dc;padding:7px 10px;border-radius:4px;font-size:11px;font-family:Inter,sans-serif;cursor:pointer;' onchange="updateNodeField(${node.id}, '${field.name}', this.value)" oninput="updateNodeField(${node.id}, '${field.name}', this.value)">${opts}</select>
                            </div>
                        `;
                    } else if (field.type === 'textarea') {
                        html += `
                            <div style='margin-bottom:14px; display:flex; gap:8px; align-items:flex-start;'>
                                <div style='flex:1;'>
                                    <label style='display:block;font-size:10px;color:#787b86;margin-bottom:6px;font-weight:500;text-transform:uppercase;letter-spacing:0.5px;'>${field.label}</label>
                                    <textarea draggable="true" ondragstart="onTextareaDragStart(event, ${node.id}, '${field.name}')" id="node_${node.id}_field_${field.name}" style='width:100%;min-height:120px;background:#131722;border:1px solid #2a2e39;color:#d1d4dc;padding:8px 10px;border-radius:4px;font-size:11px;line-height:1.5;resize:vertical;font-family:Inter,sans-serif;' onchange="updateNodeField(${node.id}, '${field.name}', this.value)" oninput="updateNodeField(${node.id}, '${field.name}', this.value)">${val}</textarea>
                                </div>
                                <div style='width:56px; display:flex; flex-direction:column; gap:6px;'>
                                    <label style='font-size:10px;color:#787b86;'>BG</label>
                                    <input type='color' value='#131722' title='Background color' onchange="updateNodeStyle(${node.id}, '${field.name}', this.value, 'background')" style='width:100%; height:36px; border-radius:4px; border:1px solid #2a2e39; padding:0; background:#131722;'/>
                                </div>
                            </div>
                        `;
                    } else {
                        html += `
                            <div style='margin-bottom:14px;'>
                                <label style='display:block;font-size:10px;color:#787b86;margin-bottom:6px;font-weight:500;text-transform:uppercase;letter-spacing:0.5px;'>${field.label}</label>
                                <input type='${field.type}' value='${val}' style='width:100%;background:#131722;border:1px solid #2a2e39;color:#d1d4dc;padding:7px 10px;border-radius:4px;font-size:11px;font-family:Inter,sans-serif;' onchange="updateNodeField(${node.id}, '${field.name}', this.value)" oninput="updateNodeField(${node.id}, '${field.name}', this.value)" />
                            </div>
                        `;
                    }
                });
            } else if (node.def.config) {
                const cfg = node.def.config;
                const val = node.configValue || cfg.value;
                if (cfg.type === 'select') {
                    const opts = cfg.options.map(o=>`<option value='${o}' ${val===o?'selected':''}>${o}</option>`).join('');
                    html += `
                        <div style='margin-bottom:12px;'>
                            <label style='display:block;font-size:11px;color:#9ca3af;margin-bottom:4px;'>${cfg.label}</label>
                            <select style='width:100%;background:#2d3239;border:1px solid #374151;color:#e5e7eb;padding:6px 8px;border-radius:4px;' onchange="updateNodeConfig(${node.id}, this.value)" oninput="updateNodeConfig(${node.id}, this.value)">${opts}</select>
                        </div>
                    `;
                } else {
                    html += `
                        <div style='margin-bottom:12px;'>
                            <label style='display:block;font-size:11px;color:#9ca3af;margin-bottom:4px;'>${cfg.label}</label>
                            <input type='${cfg.type}' value='${val}' style='width:100%;background:#2d3239;border:1px solid #374151;color:#e5e7eb;padding:6px 8px;border-radius:4px;' onchange="updateNodeConfig(${node.id}, this.value)" oninput="updateNodeConfig(${node.id}, this.value)" />
                        </div>
                    `;
                }
            } else {
                html += `<div style='color:#6b7280;font-size:12px;'>No configurable parameters for this block.</div>`;
            }
            content.innerHTML = html;
            // wire up save/discard handlers for this node
            const footer = document.getElementById('settingsFooter');
            if (footer) {
                footer.style.display = 'none';
                const saveBtn = document.getElementById('settingsSaveBtn');
                const discardBtn = document.getElementById('settingsDiscardBtn');
                if (saveBtn) {
                    saveBtn.onclick = () => { try { applyPendingNodeChanges(nodeId); } catch(e){console.warn(e);} };
                }
                if (discardBtn) {
                    discardBtn.onclick = () => { try { discardPendingNodeChanges(nodeId); } catch(e){console.warn(e);} };
                }
            }
            settingsPanel.style.transform = 'translateX(0)';
        };

        window.closeSettingsPanel = function(){
            settingsPanel.style.transform = 'translateX(100%)';
        };

        // Mark a pending change for a node (does not apply until user clicks Save)
        window.markPendingNodeChange = function(nodeId, key, value, kind) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            if (!node._pending) node._pending = { configValues: {}, configValue: undefined };
            if (kind === 'configValue') {
                node._pending.configValue = value;
            } else {
                node._pending.configValues[key] = value;
            }
            console.log(`Pending change for node ${nodeId}:`, key, value);
            // show save/discard controls
            const footer = document.getElementById('settingsFooter');
            if (footer) footer.style.display = 'flex';
        };

        // Apply pending changes for a node (save)
        window.applyPendingNodeChanges = function(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node || !node._pending) return;
            // Apply simple single-value config
            if (node._pending.configValue !== undefined) {
                node.configValue = node._pending.configValue;
            }
            // Merge configValues
            if (!node.configValues) node.configValues = {};
            Object.assign(node.configValues, node._pending.configValues || {});
            // Clean up pending
            delete node._pending;
            // hide footer
            const footer = document.getElementById('settingsFooter'); if (footer) footer.style.display = 'none';
            // Re-render node UI and persist visual updates
            const nodeEl = document.getElementById(`node-${nodeId}`);
            if (nodeEl) { nodeEl.remove(); renderNode(node); }
            // Trigger refresh of charts and insights without restarting monitor
            try { if (typeof fetchPriceHistory === 'function') fetchPriceHistory(); } catch(_) {}
            try { if (typeof window.renderPullsChart === 'function') window.renderPullsChart(); } catch(_) {}
            try { if (typeof window.updateDrawerChart === 'function') window.updateDrawerChart([], [], []); } catch(_) {}
            console.log('Applied pending changes for node', nodeId);
        };

        // Discard pending changes for a node
        window.discardPendingNodeChanges = function(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            delete node._pending;
            // hide footer
            const footer = document.getElementById('settingsFooter'); if (footer) footer.style.display = 'none';
            // Re-open settings to reset inputs to saved values
            try { openSettingsPanel(nodeId); } catch(_) {}
            console.log('Discarded pending changes for node', nodeId);
        };

        // Back-compat wrappers used by inline handlers
        window.updateNodeConfig = function(nodeId, value) { markPendingNodeChange(nodeId, 'configValue', value, 'configValue'); };

        window.updateNodeField = function(nodeId, fieldName, value) {
            // Mark field change as pending; do not apply until user clicks Save
            markPendingNodeChange(nodeId, fieldName, value, 'field');
        };

        // Update arbitrary node UI style (e.g., textarea background)
        window.updateNodeStyle = function(nodeId, fieldName, value, styleKey) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            if (!node.uiStyles) node.uiStyles = {};
            if (!node.uiStyles[fieldName]) node.uiStyles[fieldName] = {};
            node.uiStyles[fieldName][styleKey] = value;
            // Apply immediately if panel is open
            const el = document.getElementById(`node_${nodeId}_field_${fieldName}`);
            if (el) {
                if (styleKey === 'background') el.style.background = value;
                else el.style[styleKey] = value;
            }
        };

        // Dragstart handler for textareas in settings panel
        window.onTextareaDragStart = function(ev, nodeId, fieldName) {
            try {
                const el = document.getElementById(`node_${nodeId}_field_${fieldName}`);
                const bg = (el && el.style && el.style.background) ? el.style.background : '#131722';
                const payload = JSON.stringify({ content: el ? el.value : '', bg });
                ev.dataTransfer.setData('blockType', 'text_note');
                ev.dataTransfer.setData('text/plain', payload);
            } catch (e) { console.warn('dragstart failed', e); }
        };

        // Delete node
        window.deleteNode = function(id) {
            const index = state.nodes.findIndex(n => n.id === id);
            if (index !== -1) {
                state.nodes.splice(index, 1);
                document.getElementById(`node-${id}`).remove();
                
                // Remove connections involving this node
                state.connections = state.connections.filter(c => 
                    c.from.nodeId !== id && c.to.nodeId !== id
                );
                
                renderConnections();
                updateStatus();
                updatePortStyles();
            }
        };

        // Handle port clicks for connections
        function handlePortClick(dotEl) {
            const nodeId = parseInt(dotEl.dataset.nodeId);
            const portName = dotEl.dataset.port;
            const portType = dotEl.dataset.portType;

            if (!state.connectingFrom) {
                // Start connection from output port only
                if (portType === 'output') {
                    state.connectingFrom = { nodeId, portName, portType };
                    dotEl.style.background = '#f59e0b';
                    dotEl.style.borderColor = '#f59e0b';
                    // Highlight potential targets
                    document.querySelectorAll('.port-dot[data-port-type="input"]').forEach(p => p.classList.add('targetable'));
                }
            } else {
                // Complete connection to input port
                if (portType === 'input' && state.connectingFrom.portType === 'output') {
                    createConnection(
                        state.connectingFrom.nodeId,
                        state.connectingFrom.portName,
                        nodeId,
                        portName
                    );
                }
                // Reset
                resetConnectionState();
            }
        }

        // Create connection between nodes
        function createConnection(fromNodeId, fromPort, toNodeId, toPort) {
            // Check if connection already exists
            const exists = state.connections.some(c => 
                c.from.nodeId === fromNodeId && c.from.port === fromPort &&
                c.to.nodeId === toNodeId && c.to.port === toPort
            );
            
            if (!exists) {
                state.connections.push({
                    from: { nodeId: fromNodeId, port: fromPort },
                    to: { nodeId: toNodeId, port: toPort }
                });
                renderConnections();
                updateStatus();
                updatePortStyles();
            }
        }

        // Reset connection state
        function resetConnectionState() {
            document.querySelectorAll('.port-dot').forEach(dot => {
                if (!dot.classList.contains('connected')) {
                    dot.style.background = '';
                    dot.style.borderColor = '';
                }
                dot.classList.remove('targetable');
            });
            state.connectingFrom = null;
            if (state.tempConnection) {
                state.tempConnection.remove();
                state.tempConnection = null;
            }
        }

        // Update port visual states
        function updatePortStyles() {
            // Reset all
            document.querySelectorAll('.port-dot').forEach(dot => {
                dot.classList.remove('connected');
            });

            // Mark connected ports
            state.connections.forEach(conn => {
                const fromDot = document.querySelector(
                    `.port-dot[data-node-id="${conn.from.nodeId}"][data-port="${conn.from.port}"][data-port-type="output"]`
                );
                const toDot = document.querySelector(
                    `.port-dot[data-node-id="${conn.to.nodeId}"][data-port="${conn.to.port}"][data-port-type="input"]`
                );
                if (fromDot) fromDot.classList.add('connected');
                if (toDot) toDot.classList.add('connected');
            });
        }

        // Render all connections
        function renderConnections() {
            connectionLayer.innerHTML = '';
            
            state.connections.forEach((conn, index) => {
                const fromNode = state.nodes.find(n => n.id === conn.from.nodeId);
                const toNode = state.nodes.find(n => n.id === conn.to.nodeId);
                
                if (!fromNode || !toNode) return;

                const fromEl = document.querySelector(
                    `.port-dot[data-node-id="${conn.from.nodeId}"][data-port="${conn.from.port}"][data-port-type="output"]`
                );
                const toEl = document.querySelector(
                    `.port-dot[data-node-id="${conn.to.nodeId}"][data-port="${conn.to.port}"][data-port-type="input"]`
                );

                if (!fromEl || !toEl) return;

                // Get screen positions of ports
                const fromRect = fromEl.getBoundingClientRect();
                const toRect = toEl.getBoundingClientRect();
                const containerRect = canvasContainer.getBoundingClientRect();

                // Calculate positions relative to container
                const x1 = fromRect.left + fromRect.width / 2 - containerRect.left;
                const y1 = fromRect.top + fromRect.height / 2 - containerRect.top;
                const x2 = toRect.left + toRect.width / 2 - containerRect.left;
                const y2 = toRect.top + toRect.height / 2 - containerRect.top;

                drawConnection(x1, y1, x2, y2, false, index);
            });
        }

        // Draw connection line with 90-degree angles and smooth corners
        function drawConnection(x1, y1, x2, y2, isTemp = false, connectionIndex = null) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            // Calculate routing with 90-degree angles
            const horizontalGap = x2 - x1;
            const verticalGap = y2 - y1;
            const cornerRadius = 12; // Smooth corner radius
            
            // Determine routing strategy to avoid overlapping nodes
            let d;
            
            if (horizontalGap > 60) {
                // Normal case: target is significantly to the right
                // Use simple horizontal-vertical-horizontal routing
                const midX = x1 + horizontalGap / 2;
                
                if (Math.abs(verticalGap) < cornerRadius * 2) {
                    // Nearly horizontal - simple straight line with slight curve
                    d = `M ${x1} ${y1} L ${x2} ${y2}`;
                } else if (verticalGap > 0) {
                    // Going down
                    d = `
                        M ${x1} ${y1}
                        L ${midX - cornerRadius} ${y1}
                        Q ${midX} ${y1} ${midX} ${y1 + cornerRadius}
                        L ${midX} ${y2 - cornerRadius}
                        Q ${midX} ${y2} ${midX + cornerRadius} ${y2}
                        L ${x2} ${y2}
                    `;
                } else {
                    // Going up
                    d = `
                        M ${x1} ${y1}
                        L ${midX - cornerRadius} ${y1}
                        Q ${midX} ${y1} ${midX} ${y1 - cornerRadius}
                        L ${midX} ${y2 + cornerRadius}
                        Q ${midX} ${y2} ${midX + cornerRadius} ${y2}
                        L ${x2} ${y2}
                    `;
                }
            } else {
                // Target is close or to the left - route around
                const offset = 40; // How far to route around
                const rightX = Math.max(x1, x2) + offset;
                
                if (verticalGap > 0) {
                    // Route right, down, then left
                    d = `
                        M ${x1} ${y1}
                        L ${rightX - cornerRadius} ${y1}
                        Q ${rightX} ${y1} ${rightX} ${y1 + cornerRadius}
                        L ${rightX} ${y2 - cornerRadius}
                        Q ${rightX} ${y2} ${rightX - cornerRadius} ${y2}
                        L ${x2} ${y2}
                    `;
                } else {
                    // Route right, up, then left
                    d = `
                        M ${x1} ${y1}
                        L ${rightX - cornerRadius} ${y1}
                        Q ${rightX} ${y1} ${rightX} ${y1 - cornerRadius}
                        L ${rightX} ${y2 + cornerRadius}
                        Q ${rightX} ${y2} ${rightX - cornerRadius} ${y2}
                        L ${x2} ${y2}
                    `;
                }
            }
            
            path.setAttribute('d', d);
            path.setAttribute('class', isTemp ? 'connection-wire temp' : 'connection-wire');
            
            if (!isTemp && connectionIndex !== null) {
                path.style.pointerEvents = 'stroke';
                path.style.cursor = 'pointer';
                path.addEventListener('click', () => deleteConnection(connectionIndex));
                
                // Add hover tooltip
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                title.textContent = 'Click to delete connection';
                path.appendChild(title);
            }
            
            connectionLayer.appendChild(path);
            return path;
        }

        // Delete connection
        function deleteConnection(index) {
            state.connections.splice(index, 1);
            renderConnections();
            updateStatus();
            updatePortStyles();
        }

        // Mouse move for dragging
        document.addEventListener('mousemove', (e) => {
            if (state.draggedNode && !state.isPanning) {
                const node = state.draggedNode;
                node.x = (e.clientX - state.dragOffset.x) / state.zoom;
                node.y = (e.clientY - state.dragOffset.y) / state.zoom;
                const nodeEl = document.getElementById(`node-${node.id}`);
                nodeEl.style.left = `${node.x}px`;
                nodeEl.style.top = `${node.y}px`;
                renderConnections();
            } else if (state.connectingFrom) {
                // Draw temporary connection line
                const fromEl = document.querySelector(
                    `.port-dot[data-node-id="${state.connectingFrom.nodeId}"][data-port="${state.connectingFrom.portName}"][data-port-type="output"]`
                );
                
                if (fromEl) {
                    const fromRect = fromEl.getBoundingClientRect();
                    const containerRect = canvasContainer.getBoundingClientRect();

                    const x1 = fromRect.left + fromRect.width / 2 - containerRect.left;
                    const y1 = fromRect.top + fromRect.height / 2 - containerRect.top;
                    const x2 = e.clientX - containerRect.left;
                    const y2 = e.clientY - containerRect.top;

                    if (state.tempConnection) {
                        state.tempConnection.remove();
                    }
                    state.tempConnection = drawConnection(x1, y1, x2, y2, true);
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (state.draggedNode) {
                document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
                state.draggedNode = null;
                canvas.classList.remove('dragging-node');
            }
            // If we were dragging a temp connection, attempt snap-to nearest input port
            if (state.connectingFrom) {
                const pointerX = e.clientX;
                const pointerY = e.clientY;
                let best = null;
                document.querySelectorAll('.port-dot[data-port-type="input"]').forEach(dot => {
                    const r = dot.getBoundingClientRect();
                    const cx = r.left + r.width / 2;
                    const cy = r.top + r.height / 2;
                    const dist = Math.hypot(cx - pointerX, cy - pointerY);
                    if (dist < 28 && (!best || dist < best.dist)) {
                        best = { dist, el: dot };
                    }
                });
                if (best) {
                    // Simulate clicking the target port to complete connection
                    handlePortClick(best.el);
                }
            }
        });

        // Cancel connection on escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && state.connectingFrom) {
                resetConnectionState();
            }
        });

        // Click on canvas to cancel connection
        canvas.addEventListener('click', (e) => {
            if (e.target === canvas && state.connectingFrom) {
                resetConnectionState();
            }
        });

        // Canvas panning with middle mouse or space+drag
        let spacePressed = false;
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.repeat) {
                spacePressed = true;
                canvas.style.cursor = 'grab';
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
                canvas.style.cursor = state.draggedNode ? 'move' : 'grab';
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            // Enable panning on canvas background (not on nodes)
            if (e.target === canvas || e.target === connectionLayer || e.button === 1 || (spacePressed && e.button === 0)) {
                e.preventDefault();
                state.isPanning = true;
                state.panStart = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (state.isPanning) {
                const dx = (e.clientX - state.panStart.x);
                const dy = (e.clientY - state.panStart.y);
                state.canvasOffset.x += dx;
                state.canvasOffset.y += dy;
                const transform = `translate(${state.canvasOffset.x}px, ${state.canvasOffset.y}px) scale(${state.zoom})`;
                canvas.style.transform = transform;
                // connectionLayer stays in screen space
                state.panStart = { x: e.clientX, y: e.clientY };
                renderConnections();
            }
        });

        document.addEventListener('mouseup', () => {
            if (state.isPanning) {
                state.isPanning = false;
                canvas.style.cursor = 'grab';
            }
        });

        // Update status
        function updateStatus() {
            nodeCountEl.textContent = `${state.nodes.length} blocks`;
            connectionCountEl.textContent = `${state.connections.length} connections`;
            updateMinimap();
        }

        // Minimap functionality (canvas removed)
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas ? minimapCanvas.getContext('2d') : null;
        const minimapViewport = document.getElementById('minimapViewport');
        
        function updateMinimap() {
            if (!minimapCanvas || !minimapCtx) return;
            
            const rect = minimapCanvas.getBoundingClientRect();
            minimapCanvas.width = rect.width * 2;
            minimapCanvas.height = rect.height * 2;
            minimapCtx.scale(2, 2);
            
            minimapCtx.fillStyle = '#131722';
            minimapCtx.fillRect(0, 0, rect.width, rect.height);
            
            // Calculate bounds
            if (state.nodes.length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + 220);
                maxY = Math.max(maxY, node.y + 100);
            });
            
            const graphWidth = maxX - minX + 200;
            const graphHeight = maxY - minY + 200;
            const scale = Math.min(rect.width / graphWidth, rect.height / graphHeight);
            
            // Draw nodes
            minimapCtx.fillStyle = '#2a2e39';
            state.nodes.forEach(node => {
                const x = (node.x - minX + 100) * scale;
                const y = (node.y - minY + 100) * scale;
                minimapCtx.fillRect(x, y, 220 * scale, 80 * scale);
            });
            
            // Draw connections
            minimapCtx.strokeStyle = '#787b86';
            minimapCtx.lineWidth = 1;
            state.connections.forEach(conn => {
                const fromNode = state.nodes.find(n => n.id === conn.from.nodeId);
                const toNode = state.nodes.find(n => n.id === conn.to.nodeId);
                if (fromNode && toNode) {
                    const x1 = (fromNode.x - minX + 100 + 220) * scale;
                    const y1 = (fromNode.y - minY + 100 + 40) * scale;
                    const x2 = (toNode.x - minX + 100) * scale;
                    const y2 = (toNode.y - minY + 100 + 40) * scale;
                    minimapCtx.beginPath();
                    minimapCtx.moveTo(x1, y1);
                    minimapCtx.lineTo(x2, y2);
                    minimapCtx.stroke();
                }
            });
            
            // Update viewport indicator
            const viewportWidth = (window.innerWidth / state.zoom) * scale;
            const viewportHeight = (window.innerHeight / state.zoom) * scale;
            const viewportX = ((-state.panX / state.zoom) - minX + 100) * scale;
            const viewportY = ((-state.panY / state.zoom) - minY + 100) * scale;
            
            minimapViewport.style.left = `${Math.max(0, Math.min(viewportX, rect.width - viewportWidth))}px`;
            minimapViewport.style.top = `${Math.max(0, Math.min(viewportY, rect.height - viewportHeight))}px`;
            minimapViewport.style.width = `${Math.min(viewportWidth, rect.width)}px`;
            minimapViewport.style.height = `${Math.min(viewportHeight, rect.height)}px`;
        }
        
        // Click minimap to navigate
        if (minimapCanvas) {
        minimapCanvas.addEventListener('click', (e) => {
            const rect = minimapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (state.nodes.length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x + 220);
                maxY = Math.max(maxY, node.y + 100);
            });
            
            const graphWidth = maxX - minX + 200;
            const graphHeight = maxY - minY + 200;
            const scale = Math.min(rect.width / graphWidth, rect.height / graphHeight);
            
            const targetX = (x / scale) + minX - 100 - (window.innerWidth / state.zoom / 2);
            const targetY = (y / scale) + minY - 100 - (window.innerHeight / state.zoom / 2);
            
            state.panX = -targetX * state.zoom;
            state.panY = -targetY * state.zoom;
            canvas.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            renderConnections();
            updateMinimap();
        });
        }

        // Clear canvas
        document.getElementById('clearBtn').addEventListener('click', () => {
            state.nodes = [];
            state.connections = [];
            canvas.innerHTML = '';
            connectionLayer.innerHTML = '';
            updateStatus();
        });

        // Export workflow with all settings
        document.getElementById('exportBtn').addEventListener('click', () => {
            const workflow = {
                version: '1.0',
                nodes: state.nodes.map(n => ({
                    id: n.id,
                    type: n.type,
                    x: n.x,
                    y: n.y,
                    configValue: n.configValue,
                    configValues: n.configValues
                })),
                connections: state.connections
            };
            const json = JSON.stringify(workflow, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Generate filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            a.download = `workflow_${timestamp}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // Import workflow from file
        document.getElementById('importBtn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const workflow = JSON.parse(text);
                    
                    // Validate workflow structure
                    if (!workflow.nodes || !workflow.connections) {
                        alert('⚠️ Invalid workflow file format');
                        return;
                    }
                    
                    // Clear existing workflow
                    state.nodes = [];
                    state.connections = [];
                    canvas.innerHTML = '';
                    connectionLayer.innerHTML = '';
                    
                    // Restore nodes with all settings
                    const idMap = {};
                    workflow.nodes.forEach((nodeData, index) => {
                        const def = blockDefs[nodeData.type];
                        if (!def) {
                            console.warn(`Unknown block type: ${nodeData.type}`);
                            return;
                        }
                        
                        const node = {
                            id: state.nextNodeId++,
                            type: nodeData.type,
                            x: nodeData.x || 100,
                            y: nodeData.y || 100 + index * 100,
                            def: def
                        };
                        
                        // Restore config values
                        if (nodeData.configValue !== undefined) {
                            node.configValue = nodeData.configValue;
                        }
                        if (nodeData.configValues) {
                            node.configValues = { ...nodeData.configValues };
                        }
                        
                        state.nodes.push(node);
                        idMap[nodeData.id] = node.id;
                        renderNode(node);
                    });
                    
                    // Restore connections
                    workflow.connections.forEach(conn => {
                        const fromId = idMap[conn.from.nodeId];
                        const toId = idMap[conn.to.nodeId];
                        if (fromId && toId) {
                            createConnection(fromId, conn.from.port, toId, conn.to.port);
                        }
                    });
                    
                    updateStatus();
                    updatePortStyles();
                    
                    alert(`✅ Workflow loaded: ${state.nodes.length} blocks, ${state.connections.length} connections`);
                    
                } catch (err) {
                    console.error('Import error:', err);
                    alert(`❌ Failed to load workflow: ${err.message}`);
                }
            };
            input.click();
        });

        // Animation for execution flow
        async function animateExecution(nodes, indicators) {
            const execOrder = ['input', ...indicators, 'signal'];
            for (const type of execOrder) {
                const nodesOfType = nodes.filter(n => n.type === type || indicators.includes(n.type));
                for (const node of nodesOfType) {
                    const nodeEl = document.getElementById(`node-${node.id}`);
                    if (nodeEl) {
                        nodeEl.classList.add('executing');
                        await new Promise(resolve => setTimeout(resolve, 300));
                        nodeEl.classList.remove('executing');
                    }
                }
            }
        }

        // Continuous monitor helpers
        function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }
        function ensureMonitorState(){
            if (!window.monitor) {
                window.monitor = { active:false, stopRequested:false, intervalMs:1000, runs:0, history:[] };
            }
            return window.monitor;
        }
        function updateRunButton(isRunning){
            const btn = document.getElementById('runBtn');
            if (btn) btn.textContent = isRunning ? 'Stop Monitoring' : 'Run Strategy';
            const status = document.getElementById('resultsPanelStatus');
            if (status) status.textContent = isRunning ? 'Live — 60/min' : 'Ready';
        }
        function buildWorkflowRequestFromState(){
            if (!state || !Array.isArray(state.nodes) || state.nodes.length === 0) return null;
            const hasInput = state.nodes.some(n => n.type === 'input');
            if (!hasInput) return null;

            let symbol = 'SPY';
            let timeframe = '1Hour';
            let days = '7';
            let priceType = 'close';
            let alpacaKeyId = '';
            let alpacaSecretKey = '';
            const alpacaNode = state.nodes.find(n => n.type === 'alpaca_config');
            if (alpacaNode && alpacaNode.configValues) {
                symbol = alpacaNode.configValues.symbol || symbol;
                timeframe = alpacaNode.configValues.timeframe || timeframe;
                days = alpacaNode.configValues.days || days;
                priceType = alpacaNode.configValues.priceType || priceType;
                alpacaKeyId = alpacaNode.configValues.keyId || '';
                alpacaSecretKey = alpacaNode.configValues.secretKey || '';
            } else {
                const symbolNode = state.nodes.find(n => n.type === 'symbol');
                const timeframeNode = state.nodes.find(n => n.type === 'timeframe');
                const lookbackNode = state.nodes.find(n => n.type === 'lookback');
                if (symbolNode) symbol = symbolNode.configValue || symbolNode.def?.config?.value || symbol;
                if (timeframeNode) timeframe = timeframeNode.configValue || timeframeNode.def?.config?.value || timeframe;
                if (lookbackNode) days = String(lookbackNode.configValue || lookbackNode.def?.config?.value || days);
            }

            const sortedNodes = [...state.nodes].sort((a,b) => a.y - b.y);
            const workflow_blocks_ai = sortedNodes.map(n => {
                const params = {};
                if (n.configValues) Object.assign(params, n.configValues);
                if (n.type === 'ai_agent') {
                    params.provider = n.configValues?.provider || 'openai';
                    params.apiKey = n.configValues?.apiKey || '';
                    params.model = n.configValues?.model || 'gpt-4o-mini';
                    params.script = n.configValues?.script || 'Analyze the strategy.';
                    params.comments = n.configValues?.comments || '';
                    params.temperature = parseFloat(n.configValues?.temperature) || 0.7;
                    params.maxTokens = parseInt(n.configValues?.maxTokens) || 512;
                }
                return { id:n.id, type:n.type, params };
            });
            const workflow_blocks_base = workflow_blocks_ai.filter(b => b.type !== 'ai_agent');
            const hasAIBlock = workflow_blocks_ai.some(b => b.type === 'ai_agent');

            const indicators = [];
            const indicator_params = {};
            state.nodes.forEach(n => {
                if (n.type === 'rsi') {
                    indicators.push('rsi');
                    const period = parseInt(n.configValues?.period || 14);
                    const oversold = parseFloat(n.configValues?.oversold ?? 30);
                    const overbought = parseFloat(n.configValues?.overbought ?? 70);
                    if (!isNaN(period)) indicator_params['rsi'] = { period, oversold, overbought };
                } else if (n.type === 'ema') {
                    indicators.push('ema');
                    const period = parseInt(n.configValues?.period || 20); if (!isNaN(period)) indicator_params['ema'] = { period };
                } else if (n.type === 'sma') {
                    indicators.push('sma');
                    const period = parseInt(n.configValues?.period || 20); if (!isNaN(period)) indicator_params['sma'] = { period };
                } else if (n.type === 'sma_cross') {
                    indicators.push('sma_cross');
                    const fast = parseInt(n.configValues?.fast || 50);
                    const slow = parseInt(n.configValues?.slow || 200);
                    if (!isNaN(fast) && !isNaN(slow)) indicator_params['sma_cross'] = { fast, slow };
                } else if (n.type === 'macd') {
                    indicators.push('macd');
                    const fast = parseInt(n.configValues?.fast || 12);
                    const slow = parseInt(n.configValues?.slow || 26);
                    const signal = parseInt(n.configValues?.signal || 9);
                    indicator_params['macd'] = { fast, slow, signal };
                } else if (n.type === 'bollinger') {
                    indicators.push('boll');
                    const period = parseInt(n.configValues?.period || 20);
                    const std = parseFloat(n.configValues?.std || 2);
                    indicator_params['boll'] = { period, std };
                } else if (n.type === 'vwap') {
                    indicators.push('vwap');
                } else if (n.type === 'volspike') {
                    indicators.push('volspike');
                    const period = parseInt(n.configValues?.period || 20);
                    const multiplier = parseFloat(n.configValues?.multiplier || 1.5);
                    indicator_params['volspike'] = { period, multiplier };
                } else if (n.type === 'atr') {
                    indicators.push('atr');
                    const period = parseInt(n.configValues?.period || 14); indicator_params['atr'] = { period };
                } else if (n.type === 'stochastic') {
                    indicators.push('stoch');
                    const period = parseInt(n.configValues?.period || 14);
                    const smoothK = parseInt(n.configValues?.smoothK || 3);
                    const smoothD = parseInt(n.configValues?.smoothD || 3);
                    indicator_params['stoch'] = { period, smoothK, smoothD };
                } else if (n.type === 'obv') {
                    indicators.push('obv');
                } else if (n.type === 'trendline') {
                    indicators.push('trendline');
                    const lookback = parseInt(n.configValues?.lookback || 100);
                    const numTrendlines = parseInt(n.configValues?.numTrendlines || 2);
                    const pivotWindow = parseInt(n.configValues?.pivotWindow || 3);
                    const tolerancePct = parseFloat(n.configValues?.tolerancePct || 0.5);
                    const minTouches = parseInt(n.configValues?.minTouches || 2);
                    indicator_params['trendline'] = { lookback, numTrendlines, pivotWindow, tolerancePct, minTouches };
                }
            });

            const sanitizedContextBlocks = sortedNodes.map(n => {
                const p = {};
                if (n.configValues) Object.assign(p, n.configValues);
                if (n.type === 'alpaca_config') { if ('keyId' in p) delete p.keyId; if ('secretKey' in p) delete p.secretKey; }
                if (n.type === 'ai_agent') { if ('apiKey' in p) delete p.apiKey; }
                return { type: n.type, params: p };
            });
            const selectedIndicatorsList = indicators.slice();
            workflow_blocks_ai.forEach(b => {
                if (b.type === 'ai_agent') {
                    b.params.context = { symbol, timeframe, days: parseInt(days), indicators: selectedIndicatorsList, indicator_params, blocks: sanitizedContextBlocks };
                }
            });

            return { symbol, timeframe, days, priceType, alpacaKeyId, alpacaSecretKey, indicators, indicator_params, workflow_blocks_base, workflow_blocks_ai, hasAIBlock };
        }
        async function startContinuousMonitor(){
            const mon = ensureMonitorState();
            if (mon.active) return;
            mon.active = true; mon.stopRequested = false; updateRunButton(true);
            // Do not force-open the insights panel when monitoring starts — show the chart drawer instead
            const drawer = document.getElementById('chartDrawer');
            if (drawer) {
                // Open drawer to the same expanded height as the Expand button
                drawer.classList.add('expanded');
                const header = drawer.querySelector('.chart-drawer-header');
                const body = drawer.querySelector('.chart-drawer-body');
                const headerH = header ? header.offsetHeight : 48;
                const bodyScroll = body ? body.scrollHeight : (drawer.scrollHeight - headerH);
                const topMargin = 80; // keep same top margin used by expand behavior
                const extraPadding = 12;
                const desired = Math.min(window.innerHeight - topMargin, headerH + bodyScroll + extraPadding);
                drawer.style.height = Math.max(120, desired) + 'px';
                const expandBtn = document.getElementById('drawerExpandBtn');
                if (expandBtn) expandBtn.textContent = 'Minimize';
                // Ensure the drawer allows content to show and force an initial draw of the pulls chart
                drawer.style.overflow = 'visible';
                try { if (typeof window.renderPullsChart === 'function') window.renderPullsChart(); } catch(_) {}
                // Also schedule a redraw after the expand transition completes
                setTimeout(() => { try { if (typeof window.renderPullsChart === 'function') window.renderPullsChart(); } catch(_) {} }, 350);
            }
            // Clear charts and signals so Run/Monitor starts fresh
            try {
                window.signalHistory = [];
                if (typeof updateSignalList === 'function') updateSignalList();
                window.priceHistoryBars = [];
                const pullsCanvas = document.getElementById('drawerPullsChart');
                if (pullsCanvas && pullsCanvas.getContext) {
                    const ctx = pullsCanvas.getContext('2d');
                    ctx.clearRect(0, 0, pullsCanvas.width, pullsCanvas.height);
                }
                const sigCanvas = document.getElementById('signalHistoryChart');
                if (sigCanvas && sigCanvas.getContext) {
                    const ctx2 = sigCanvas.getContext('2d');
                    ctx2.clearRect(0, 0, sigCanvas.width, sigCanvas.height);
                }
            } catch (e) { console.warn('Failed to clear charts on start:', e); }
            const aiBox = document.getElementById('aiAnalysisBox');
            if (aiBox) {
                const hasAI = (state && Array.isArray(state.nodes)) ? state.nodes.some(n => n.type === 'ai_agent') : false;
                aiBox.innerHTML = `
                    <div class="ai-analysis-label">
                        <div class="ai-status-dot"></div>
                        Live monitoring active...
                    </div>
                    <div style="display:flex; align-items:center; gap:12px; margin-top:8px;">
                        <div class="loading-spinner" style="width:18px; height:18px; border-width:2px;"></div>
                        <div style="font-size:12px; color:#9ca3af;">Polling backend at ~60 requests/min</div>
                    </div>
                    ${hasAI ? '<div style="margin-top:6px; font-size:12px; color:#6b7280;">AI analysis will run on confirmed signals.</div>' : ''}
                    <div style="margin-top:8px; font-size:10px; letter-spacing:0.5px; color:#a78bfa; text-transform:uppercase;">Continuous Strategy Monitor</div>
                `;
            }
            while(mon.active && !mon.stopRequested){
                const t0 = Date.now();
                try {
                    const params = buildWorkflowRequestFromState();
                    if (!params) { await sleep(mon.intervalMs); continue; }
                    const { symbol, timeframe, days, priceType, alpacaKeyId, alpacaSecretKey, indicators, indicator_params, workflow_blocks_base, workflow_blocks_ai, hasAIBlock } = params;
                    const [strategyResponse, workflowResponse] = await Promise.all([
                        fetch('http://localhost:5000/execute', {
                            method: 'POST', headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ symbol, timeframe, days: parseInt(days), indicators, indicator_params, alpacaKeyId, alpacaSecretKey })
                        }),
                        fetch('http://localhost:5000/execute_workflow', {
                            method: 'POST', headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ symbol, timeframe, days: parseInt(days), priceType, workflow: workflow_blocks_base, indicator_params, alpacaKeyId, alpacaSecretKey })
                        })
                    ]);
                    const strategyData = await strategyResponse.json();
                    const workflowData = await workflowResponse.json();
                    if (strategyResponse.ok && workflowResponse.ok) {
                        // Debug: log summary of responses so we can trace why signals aren't showing
                        try {
                            const _latestPrice = (workflowData && workflowData.latest_data && typeof workflowData.latest_data.price === 'number') ? workflowData.latest_data.price : (strategyData && strategyData.latest && typeof strategyData.latest.close === 'number') ? strategyData.latest.close : null;
                            console.log('monitor: received responses', { final_decision: workflowData.final_decision, success: workflowData.success, latestPrice: _latestPrice });
                        } catch(_){ }
                        // Update UI
                        displayCombinedResults(strategyData, workflowData, indicators, symbol, timeframe, days);
                        if (typeof window.updateDrawerChart === 'function' && workflowData.historical_bars) {
                            const bars = workflowData.historical_bars;
                            const prices = bars.close || [];
                            const strategy = prices.map((p, i) => { const base=10000; const pct = i===0?0:(p - prices[0]) / prices[0]; return base * (1 + pct); });
                            const timestamps = bars.timestamps || [];
                            window.updateDrawerChart(prices, strategy, timestamps);
                        }
                        // Store history
                        const latestPrice = (workflowData && workflowData.latest_data && typeof workflowData.latest_data.price === 'number')
                            ? workflowData.latest_data.price
                            : (workflowData && workflowData.latest_data && typeof workflowData.latest_data.close === 'number')
                                ? workflowData.latest_data.close
                                : (strategyData && strategyData.latest && typeof strategyData.latest.close === 'number')
                                    ? strategyData.latest.close
                                    : null;
                        mon.runs += 1;
                        mon.history.push({ ts:new Date().toISOString(), symbol, timeframe, priceType, latestPrice, finalDecision: workflowData.final_decision, success: workflowData.success });
                        if (mon.history.length > 1000) mon.history.shift();
                        if (window.vars) window.vars.setMany({ monitorRuns: mon.runs, monitorLastTs: mon.history[mon.history.length-1].ts });
                        try { localStorage.setItem('flowgrid_monitor_history', JSON.stringify(mon.history.slice(-200))); } catch(_){}

                        // Update live pulls chart
                        if (typeof window.renderPullsChart === 'function') {
                            window.renderPullsChart();
                        }

                        // Gate AI: only run AI agent workflow when a signal is confirmed
                        const confirmed = workflowData && workflowData.success && workflowData.final_decision === 'CONFIRMED';
                        if (confirmed && hasAIBlock) {
                            try {
                                const aiResp = await fetch('http://localhost:5000/execute_workflow', {
                                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ symbol, timeframe, days: parseInt(days), priceType, workflow: workflow_blocks_ai, indicator_params, alpacaKeyId, alpacaSecretKey })
                                });
                                const aiData = await aiResp.json();
                                if (aiResp.ok) {
                                    displayCombinedResults(strategyData, aiData, indicators, symbol, timeframe, days);
                                }
                            } catch(e) { console.warn('AI gated run failed:', e); }
                        }
                    }
                } catch(e) { console.warn('Monitor iteration failed:', e); }
                const elapsed = Date.now() - t0;
                const wait = Math.max(0, ensureMonitorState().intervalMs - elapsed);
                await sleep(wait);
            }
            ensureMonitorState().active = false; updateRunButton(false);
        }
        function stopContinuousMonitor(){ const mon = ensureMonitorState(); mon.stopRequested = true; }

        // Run strategy - integrate with Python backend (unified execution)
        document.getElementById('runBtn').addEventListener('click', async () => {
            // Toggle continuous monitor on Run button
            const mon = ensureMonitorState();
            if (!mon.active) { startContinuousMonitor(); return; }
            else { stopContinuousMonitor(); return; }
            if (state.nodes.length === 0) {
                return;
            }

            // Validate workflow has input (no alert, just skip)
            const hasInput = state.nodes.some(n => n.type === 'input');
            if (!hasInput) {
                return;
            }

            // Build execution graph
            const workflow = {
                nodes: state.nodes.map(n => ({
                    id: n.id,
                    type: n.type,
                    name: n.def.name
                })),
                connections: state.connections
            };

            // Get config from blocks or use defaults (unified alpaca_config preference)
            let symbol = 'SPY';
            let timeframe = '1Hour';
            let days = '7';
            let priceType = 'close';

            const alpacaNode = state.nodes.find(n => n.type === 'alpaca_config');
            let alpacaKeyId = '';
            let alpacaSecretKey = '';
            if (alpacaNode && alpacaNode.configValues) {
                symbol = alpacaNode.configValues.symbol || symbol;
                timeframe = alpacaNode.configValues.timeframe || timeframe;
                days = alpacaNode.configValues.days || days;
                priceType = alpacaNode.configValues.priceType || priceType;
                alpacaKeyId = alpacaNode.configValues.keyId || '';
                alpacaSecretKey = alpacaNode.configValues.secretKey || '';
            } else {
                // Fallback to legacy individual blocks
                const symbolNode = state.nodes.find(n => n.type === 'symbol');
                const timeframeNode = state.nodes.find(n => n.type === 'timeframe');
                const lookbackNode = state.nodes.find(n => n.type === 'lookback');

                if (symbolNode) symbol = symbolNode.configValue || symbolNode.def.config.value;
                if (timeframeNode) timeframe = timeframeNode.configValue || timeframeNode.def.config.value;
                if (lookbackNode) days = String(lookbackNode.configValue || lookbackNode.def.config.value);
            }

            // Build workflow blocks for sequential execution
            const sortedNodes = [...state.nodes].sort((a, b) => a.y - b.y);
            const workflow_blocks = sortedNodes.map(n => {
                const params = {};
                if (n.configValues) Object.assign(params, n.configValues);
                // For ai_agent, ensure all config is captured (without secrets)
                if (n.type === 'ai_agent') {
                    params.provider = n.configValues?.provider || 'openai';
                    // Include apiKey for backend to call provider; do NOT put it in context or UI
                    params.apiKey = n.configValues?.apiKey || '';
                    params.model = n.configValues?.model || 'gpt-4o-mini';
                    params.script = n.configValues?.script || 'Analyze the strategy.';
                    params.comments = n.configValues?.comments || '';
                    params.temperature = parseFloat(n.configValues?.temperature) || 0.7;
                    params.maxTokens = parseInt(n.configValues?.maxTokens) || 512;
                }
                return { id: n.id, type: n.type, params: params };
            });

            // Normalize indicator & block params for backend evaluators
            workflow_blocks.forEach(b => {
                if (b.type === 'rsi') {
                    const oversoldRaw = b.params.oversold ?? b.params.threshold_low ?? 30;
                    const overboughtRaw = b.params.overbought ?? b.params.threshold_high ?? 70;
                    const oversold = parseFloat(oversoldRaw);
                    const overbought = parseFloat(overboughtRaw);
                    if (!isNaN(oversold) && !isNaN(overbought)) {
                        b.params.threshold_low = Math.min(oversold, overbought);
                        b.params.threshold_high = Math.max(oversold, overbought);
                    }
                    if (b.params.condition) b.params.rsi_condition = b.params.condition; // any/oversold/overbought/neutral
                }
                if (b.type === 'stochastic') {
                    const os = parseFloat(b.params.oversold ?? 20);
                    const ob = parseFloat(b.params.overbought ?? 80);
                    if (!isNaN(os) && !isNaN(ob)) {
                        b.params.stoch_low = Math.min(os, ob);
                        b.params.stoch_high = Math.max(os, ob);
                    }
                    if (b.params.condition) b.params.stoch_condition = b.params.condition; // oversold/overbought/any/k_cross_d_up/k_cross_d_down
                }
                if (b.type === 'bollinger') {
                    const cond = b.params.condition;
                    if (cond === 'above_upper') b.params.boll_condition = 'touch_upper';
                    else if (cond === 'below_lower') b.params.boll_condition = 'touch_lower';
                    else if (cond === 'squeeze') b.params.boll_condition = 'squeeze';
                    else if (cond === 'expansion') b.params.boll_condition = 'expansion';
                    else b.params.boll_condition = 'any';
                    if (b.params.squeezeThreshold) b.params.boll_squeeze_threshold = parseFloat(b.params.squeezeThreshold);
                }
                if (b.type === 'macd') {
                    if (b.params.histThreshold) b.params.macd_hist_threshold = parseFloat(b.params.histThreshold);
                    if (b.params.condition) b.params.macd_condition = b.params.condition; // any/bullish_cross/bearish_cross/positive/negative
                }
                if (b.type === 'vwap') {
                    if (b.params.condition) b.params.vwap_condition = b.params.condition; // any/above/below/cross_up/cross_down
                }
                if (b.type === 'obv') {
                    if (b.params.condition) b.params.obv_condition = b.params.condition; // any/rising/falling/divergence_bull/divergence_bear
                }
                if (b.type === 'trendline') {
                    if (!b.params.direction) b.params.direction = 'bullish';
                }
                if (b.type === 'sma_cross') {
                    if (b.params.crossType) b.params.sma_cross_type = b.params.crossType; // any/bullish/bearish
                    const fast = parseInt(b.params.fast ?? 50); const slow = parseInt(b.params.slow ?? 200);
                    if (!isNaN(fast) && !isNaN(slow)) { b.params.sma_fast = fast; b.params.sma_slow = slow; }
                }
            });

            // Generate indicator list & parameter objects
            const indicators = [];
            const indicator_params = {};
            state.nodes.forEach(n => {
                if (n.type === 'rsi') {
                    indicators.push('rsi');
                    const period = parseInt(n.configValues?.period || 14);
                    const oversold = parseFloat(n.configValues?.oversold ?? 30);
                    const overbought = parseFloat(n.configValues?.overbought ?? 70);
                    if (!isNaN(period)) indicator_params['rsi'] = { period, oversold, overbought };
                } else if (n.type === 'ema') {
                    indicators.push('ema');
                    const period = parseInt(n.configValues?.period || 20); if (!isNaN(period)) indicator_params['ema'] = { period };
                } else if (n.type === 'sma') {
                    indicators.push('sma');
                    const period = parseInt(n.configValues?.period || 20); if (!isNaN(period)) indicator_params['sma'] = { period };
                } else if (n.type === 'sma_cross') {
                    indicators.push('sma_cross');
                    const fast = parseInt(n.configValues?.fast || 50);
                    const slow = parseInt(n.configValues?.slow || 200);
                    if (!isNaN(fast) && !isNaN(slow)) indicator_params['sma_cross'] = { fast, slow };
                } else if (n.type === 'macd') {
                    indicators.push('macd');
                    const fast = parseInt(n.configValues?.fast || 12);
                    const slow = parseInt(n.configValues?.slow || 26);
                    const signal = parseInt(n.configValues?.signal || 9);
                    indicator_params['macd'] = { fast, slow, signal };
                } else if (n.type === 'bollinger') {
                    indicators.push('boll');
                    const period = parseInt(n.configValues?.period || 20);
                    const std = parseFloat(n.configValues?.std || 2);
                    indicator_params['boll'] = { period, std };
                } else if (n.type === 'vwap') {
                    indicators.push('vwap');
                } else if (n.type === 'volspike') {
                    indicators.push('volspike');
                    const period = parseInt(n.configValues?.period || 20);
                    const multiplier = parseFloat(n.configValues?.multiplier || 1.5);
                    indicator_params['volspike'] = { period, multiplier };
                } else if (n.type === 'atr') {
                    indicators.push('atr');
                    const period = parseInt(n.configValues?.period || 14); indicator_params['atr'] = { period };
                } else if (n.type === 'stochastic') {
                    indicators.push('stoch');
                    const period = parseInt(n.configValues?.period || 14);
                    const smoothK = parseInt(n.configValues?.smoothK || 3);
                    const smoothD = parseInt(n.configValues?.smoothD || 3);
                    indicator_params['stoch'] = { period, smoothK, smoothD };
                } else if (n.type === 'obv') {
                    indicators.push('obv');
                } else if (n.type === 'trendline') {
                    indicators.push('trendline');
                    const lookback = parseInt(n.configValues?.lookback || 100);
                    const numTrendlines = parseInt(n.configValues?.numTrendlines || 2);
                    const pivotWindow = parseInt(n.configValues?.pivotWindow || 3);
                    const tolerancePct = parseFloat(n.configValues?.tolerancePct || 0.5);
                    const minTouches = parseInt(n.configValues?.minTouches || 2);
                    indicator_params['trendline'] = { lookback, numTrendlines, pivotWindow, tolerancePct, minTouches };
                }
            });

            if (indicators.length === 0) {
                return;
            }

            // Build sanitized context for AI agent blocks (include indicator settings & workflow structure, exclude any keys)
            const selectedIndicatorsList = indicators.slice();
            const sanitizedContextBlocks = sortedNodes.map(n => {
                const p = {};
                if (n.configValues) Object.assign(p, n.configValues);
                // Strip any secrets if present in config values
                if (n.type === 'alpaca_config') {
                    if ('keyId' in p) delete p.keyId;
                    if ('secretKey' in p) delete p.secretKey;
                }
                if (n.type === 'ai_agent') {
                    if ('apiKey' in p) delete p.apiKey;
                }
                return { type: n.type, params: p };
            });

            // Inject context into AI agent blocks and ensure no keys are present in context
            workflow_blocks.forEach(b => {
                if (b.type === 'ai_agent') {
                    b.params.context = {
                        symbol,
                        timeframe,
                        days: parseInt(days),
                        indicators: selectedIndicatorsList,
                        indicator_params,
                        blocks: sanitizedContextBlocks
                    };
                }
            });

            const indicatorStr = indicators.join(',');
            const command = `python strategy_cli.py --symbol ${symbol} --timeframe ${timeframe} --days ${days} --indicators ${indicatorStr} --show-last 10`;

            // Ensure insights panel is open & show loading state
            const insightsPanel = document.getElementById('resultsPanel');
            if (insightsPanel && !insightsPanel.classList.contains('open')) {
                insightsPanel.classList.add('open');
            }
            const aiBox = document.getElementById('aiAnalysisBox');
            const hasAIBlock = state.nodes.some(n => n.type === 'ai_agent');
            if (aiBox) {
                let loadingHTML = `
                    <div class="ai-analysis-label">
                        <div class="ai-status-dot"></div>
                        Live monitoring active...
                    </div>
                    <div style="display:flex; flex-direction:column; gap:12px;">
                        <div style="display:flex; align-items:center; gap:12px;">
                            <div class="loading-spinner" style="width:20px; height:20px; border-width:2px;"></div>
                            <div style="font-size:12px; color:#9ca3af;">Monitoring market conditions...</div>
                        </div>
                        <div style="display:flex; align-items:center; gap:12px;">
                            <div class="loading-spinner" style="width:20px; height:20px; border-width:2px; animation-delay:.4s;"></div>
                            <div style="font-size:12px; color:#9ca3af;">Analyzing indicator signals...</div>
                        </div>`;
                if (hasAIBlock) {
                    loadingHTML += `
                        <div style="display:flex; align-items:center; gap:12px;">
                            <div class="loading-spinner" style="width:20px; height:20px; border-width:2px; animation-delay:.8s;"></div>
                            <div style="font-size:12px; color:#9ca3af;">AI agent analyzing strategy...</div>
                        </div>`;
                } else {
                    loadingHTML += `
                        <div style="display:flex; align-items:center; gap:12px;">
                            <div style="width:20px; height:20px; border-radius:50%; background:#1e2530; display:flex; align-items:center; justify-content:center; font-size:11px; color:#6b7280; font-weight:600;">AI</div>
                            <div style="font-size:12px; color:#6b7280;">No AI Agent block detected – skipping AI model request.</div>
                        </div>`;
                }
                loadingHTML += `
                        <div style="margin-top:8px; font-size:10px; letter-spacing:0.5px; color:#a78bfa; text-transform:uppercase;">Continuous Strategy Monitor</div>
                    </div>`;
                aiBox.innerHTML = loadingHTML;
            }

            try {
                // Execute both strategy indicators and workflow evaluation in parallel
                const [strategyResponse, workflowResponse] = await Promise.all([
                    fetch('http://localhost:5000/execute', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            symbol,
                            timeframe,
                            days: parseInt(days),
                            indicators,
                            indicator_params,
                            alpacaKeyId,
                            alpacaSecretKey
                        })
                    }),
                    fetch('http://localhost:5000/execute_workflow', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            symbol,
                            timeframe,
                            days: parseInt(days),
                            priceType,
                            workflow: workflow_blocks,
                            indicator_params,
                            alpacaKeyId,
                            alpacaSecretKey
                        })
                    })
                ]);

                const strategyData = await strategyResponse.json();
                const workflowData = await workflowResponse.json();
                
                if (!strategyResponse.ok || !workflowResponse.ok) {
                    throw new Error(strategyData.error || workflowData.error || 'Backend error');
                }

                // Animate workflow execution
                if (workflowData.blocks && Array.isArray(workflowData.blocks)) {
                    await animateExecution(state.nodes, indicators);
                }
                
                // Display combined results (legacy right panel if still visible)
                displayCombinedResults(strategyData, workflowData, indicators, symbol, timeframe, days);

                // Update bottom drawer chart with historical data
                if (typeof window.updateDrawerChart === 'function' && workflowData.historical_bars) {
                    const bars = workflowData.historical_bars;
                    const prices = bars.close || [];
                    // For strategy equity, use cumulative P&L or just track price for now
                    // Backend should eventually provide equity curve
                    const strategy = prices.map((p, i) => {
                        // Simple equity simulation: start at 10000, track price percentage changes
                        const baseEquity = 10000;
                        const pctChange = i === 0 ? 0 : (p - prices[0]) / prices[0];
                        return baseEquity * (1 + pctChange);
                    });
                    const timestamps = bars.timestamps || [];
                    
                    console.log('Feeding chart data:', { prices: prices.length, strategy: strategy.length, timestamps: timestamps.length });
                    window.updateDrawerChart(prices, strategy, timestamps);
                }

                // After results, conditionally fetch Gemini analysis only if AI Agent present
                if (hasAIBlock && typeof fetchGeminiAnalysis === 'function') {
                    fetchGeminiAnalysis({ symbol, timeframe, strategyData, workflowData })
                        .catch(err => console.warn('Gemini analysis failed:', err));
                }

            } catch (err) {
                console.error('Backend connection error:', err);
                
                // Fallback: show command for manual execution
                // Legacy panel hidden; show error inside insights panel instead
                if (aiBox) {
                    aiBox.innerHTML = `
                        <div class="ai-analysis-label" style="color:#ef4444;">
                            <div style="width:6px;height:6px;border-radius:50%;background:#ef4444;"></div>
                            Backend Error
                        </div>
                        <div class="ai-analysis-text" style="color:#fca5a5;">${err.message || 'Could not connect to backend.'}</div>
                        <div style="font-size:11px; color:#9ca3af; margin-top:8px; line-height:1.6;">
                            Start backend: <code style="background:#000;padding:2px 6px;border-radius:3px;">python backend.py</code> then rerun.
                        </div>
                    `;
                }
                outputContent.innerHTML = `
                    <div class="output-section">
                        <h4>⚠️ Backend Server Not Running</h4>
                        <p class="output-text" style="color: #f59e0b;">
                            ${err.message || 'Could not connect to localhost:5000'}
                        </p>
                        <p class="output-text" style="color: #9ca3af; font-size: 12px; margin-top: 10px;">
                            The backend server is either not running or there's a connection issue.
                        </p>
                    </div>
                    <div class="output-section">
                        <h4>🔧 Quick Fix</h4>
                        <ol style="color: #9ca3af; font-size: 13px; line-height: 1.8; margin-top: 10px;">
                            <li>Open a new terminal in VS Code</li>
                            <li>Run: <code style="background: #000; padding: 2px 6px; border-radius: 3px;">python backend.py</code></li>
                            <li>Click the "🔌 Test Backend" button to verify</li>
                            <li>Then try "Run Strategy" again</li>
                        </ol>
                    </div>
                    <div class="output-section">
                        <h4>Manual Command (Alternative)</h4>
                        <div class="output-text" style="background: #000; padding: 12px; border-radius: 6px; margin-top: 10px; font-size: 11px; word-break: break-all;">
                            ${command}
                        </div>
                        <button onclick="navigator.clipboard.writeText('${command}').then(() => alert('✅ Copied to clipboard!'))"
                                style="margin-top: 10px; padding: 8px 16px; background: #3b82f6; border: none; color: white; border-radius: 6px; cursor: pointer;">
                            📋 Copy Command
                        </button>
                    </div>
                `;
            }
        });

        // Analyze signals and generate conclusion
        function analyzeSignals(indicators, latestData) {
            const signals = [];
            let bullishCount = 0;
            let bearishCount = 0;

            indicators.forEach(ind => {
                let signal = { name: ind, sentiment: 'neutral', reason: '' };

                if (ind === 'rsi' && latestData.rsi !== undefined) {
                    const rsi = latestData.rsi;
                    // Pull user-configured thresholds from first RSI node (fallback to defaults)
                    const rsiNode = state.nodes.find(n => n.type === 'rsi');
                    const oversold = parseFloat(rsiNode?.configValues?.oversold ?? 30);
                    const overbought = parseFloat(rsiNode?.configValues?.overbought ?? 70);
                    const low = Math.min(oversold, overbought);
                    const high = Math.max(oversold, overbought);
                    if (rsi < low) {
                        signal.sentiment = 'bullish';
                        signal.reason = `RSI ${rsi.toFixed(2)} below ${low} (user oversold) – potential bullish reversal`;
                        bullishCount++;
                    } else if (rsi > high) {
                        signal.sentiment = 'bearish';
                        signal.reason = `RSI ${rsi.toFixed(2)} above ${high} (user overbought) – potential bearish reversal`;
                        bearishCount++;
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `RSI ${rsi.toFixed(2)} in neutral band (${low}-${high})`;
                    }
                } else if (ind === 'ema' && latestData.ema !== undefined && latestData.close !== undefined) {
                    const ema = latestData.ema;
                    const close = latestData.close;
                    if (close > ema) {
                        signal.sentiment = 'bullish';
                        signal.reason = `Price $${close.toFixed(2)} above EMA $${ema.toFixed(2)} - Uptrend`;
                        bullishCount++;
                    } else if (close < ema) {
                        signal.sentiment = 'bearish';
                        signal.reason = `Price $${close.toFixed(2)} below EMA $${ema.toFixed(2)} - Downtrend`;
                        bearishCount++;
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `Price at EMA - Consolidation`;
                    }
                } else if (ind === 'sma' && latestData.sma !== undefined && latestData.close !== undefined) {
                    const sma = latestData.sma;
                    const close = latestData.close;
                    if (close > sma) {
                        signal.sentiment = 'bullish';
                        signal.reason = `Price $${close.toFixed(2)} above SMA $${sma.toFixed(2)} - Uptrend bias`;
                        bullishCount++;
                    } else if (close < sma) {
                        signal.sentiment = 'bearish';
                        signal.reason = `Price $${close.toFixed(2)} below SMA $${sma.toFixed(2)} - Downtrend bias`;
                        bearishCount++;
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `Price at SMA - No bias`;
                    }
                } else if (ind === 'sma_cross') {
                    const crossed = latestData.sma_cross;
                    const dir = latestData.sma_cross_dir;
                    const fast = latestData.sma_fast;
                    const slow = latestData.sma_slow;
                    if (crossed && dir === 'bullish') {
                        signal.sentiment = 'bullish';
                        signal.reason = `Golden Cross detected (50 > 200). Fast SMA ${fast ? fast.toFixed(2) : 'n/a'} above Slow SMA ${slow ? slow.toFixed(2) : 'n/a'}`;
                        bullishCount++;
                    } else if (crossed && dir === 'bearish') {
                        signal.sentiment = 'bearish';
                        signal.reason = `Death Cross detected (50 < 200). Fast SMA ${fast ? fast.toFixed(2) : 'n/a'} below Slow SMA ${slow ? slow.toFixed(2) : 'n/a'}`;
                        bearishCount++;
                    } else if (fast !== undefined && slow !== undefined) {
                        if (fast !== null && slow !== null) {
                            if (fast > slow) {
                                signal.sentiment = 'bullish';
                                signal.reason = `No new cross. Fast SMA ${fast.toFixed(2)} remains above Slow SMA ${slow.toFixed(2)}`;
                                bullishCount++;
                            } else if (fast < slow) {
                                signal.sentiment = 'bearish';
                                signal.reason = `No new cross. Fast SMA ${fast.toFixed(2)} remains below Slow SMA ${slow.toFixed(2)}`;
                                bearishCount++;
                            } else {
                                signal.sentiment = 'neutral';
                                signal.reason = `SMAs equal - No trend bias`;
                            }
                        } else {
                            signal.sentiment = 'neutral';
                            signal.reason = `SMA values not available yet (insufficient data)`;
                        }
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `No recent SMA cross event`;
                    }
                } else if (ind === 'macd' && latestData.macd_hist !== undefined) {
                    const hist = latestData.macd_hist;
                    if (hist > 0) {
                        signal.sentiment = 'bullish';
                        signal.reason = `MACD histogram ${hist.toFixed(3)} - Positive momentum`;
                        bullishCount++;
                    } else if (hist < 0) {
                        signal.sentiment = 'bearish';
                        signal.reason = `MACD histogram ${hist.toFixed(3)} - Negative momentum`;
                        bearishCount++;
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `MACD histogram at zero - No momentum`;
                    }
                } else if (ind === 'boll' && latestData.boll_upper !== undefined) {
                    const close = latestData.close;
                    const upper = latestData.boll_upper;
                    const lower = latestData.boll_lower;
                    if (close > upper) {
                        signal.sentiment = 'bearish';
                        signal.reason = `Price above upper band - Overbought`;
                        bearishCount++;
                    } else if (close < lower) {
                        signal.sentiment = 'bullish';
                        signal.reason = `Price below lower band - Oversold`;
                        bullishCount++;
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `Price within bands - Normal range`;
                    }
                } else if (ind === 'vwap' && latestData.vwap !== undefined) {
                    const close = latestData.close;
                    const vwap = latestData.vwap;
                    if (close > vwap) {
                        signal.sentiment = 'bullish';
                        signal.reason = `Price above VWAP $${vwap.toFixed(2)} - Institutional buying pressure`;
                        bullishCount++;
                    } else if (close < vwap) {
                        signal.sentiment = 'bearish';
                        signal.reason = `Price below VWAP $${vwap.toFixed(2)} - Institutional selling pressure`;
                        bearishCount++;
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `Price at VWAP - Fair value`;
                    }
                } else if (ind === 'volspike' && latestData.vol_spike !== undefined) {
                    if (latestData.vol_spike) {
                        signal.sentiment = 'bullish';
                        signal.reason = `Volume spike detected - Increased interest (direction depends on price action)`;
                        bullishCount++;
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `Normal volume - No unusual activity`;
                    }
                } else if (ind === 'atr' && latestData.atr !== undefined) {
                    signal.sentiment = 'neutral';
                    signal.reason = `ATR at ${latestData.atr.toFixed(2)} - Volatility measure (not directional)`;
                } else if (ind === 'stoch' && latestData.stoch_k !== undefined) {
                    const k = latestData.stoch_k;
                    if (k < 20) {
                        signal.sentiment = 'bullish';
                        signal.reason = `Stochastic %K at ${k.toFixed(2)} - Oversold`;
                        bullishCount++;
                    } else if (k > 80) {
                        signal.sentiment = 'bearish';
                        signal.reason = `Stochastic %K at ${k.toFixed(2)} - Overbought`;
                        bearishCount++;
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `Stochastic %K at ${k.toFixed(2)} - Neutral`;
                    }
                } else if (ind === 'obv') {
                    signal.sentiment = 'neutral';
                    signal.reason = `OBV - Volume accumulation indicator (trend needs context)`;
                } else if (ind === 'trendline') {
                    const breakout = latestData.trend_breakout;
                    const slope = latestData.trend_slope;
                    const support = latestData.trend_support;
                    const resistance = latestData.trend_resistance;
                    const ht = latestData.trend_high_touches;
                    const lt = latestData.trend_low_touches;
                    if (breakout === 'bullish') {
                        signal.sentiment = 'bullish';
                        signal.reason = `Bullish breakout above resistance (${resistance ? resistance.toFixed(2) : 'n/a'}) after ${ht} touches`;
                        bullishCount++;
                    } else if (breakout === 'bearish') {
                        signal.sentiment = 'bearish';
                        signal.reason = `Bearish breakdown below support (${support ? support.toFixed(2) : 'n/a'}) after ${lt} touches`;
                        bearishCount++;
                    } else if (slope === 'up') {
                        signal.sentiment = 'bullish';
                        signal.reason = `Ascending trend channel intact (support ${support ? support.toFixed(2) : 'n/a'})`;
                        bullishCount++;
                    } else if (slope === 'down') {
                        signal.sentiment = 'bearish';
                        signal.reason = `Descending trend channel intact (resistance ${resistance ? resistance.toFixed(2) : 'n/a'})`;
                        bearishCount++;
                    } else {
                        signal.sentiment = 'neutral';
                        signal.reason = `No clear trendline or breakout (touches H:${ht} L:${lt})`;
                    }
                }

                signals.push(signal);
            });

            // Generate overall conclusion
            const total = bullishCount + bearishCount;
            let overallSentiment = 'neutral';
            let conclusion = '';
            let recommendation = '';

            if (total === 0) {
                overallSentiment = 'neutral';
                conclusion = 'All indicators are neutral or inconclusive.';
                recommendation = 'Wait for clearer signals. Consider adding more indicators or checking multiple timeframes.';
            } else {
                const bullishPercent = (bullishCount / total) * 100;
                const bearishPercent = (bearishCount / total) * 100;

                if (bullishCount > bearishCount) {
                    overallSentiment = 'bullish';
                    conclusion = `${bullishCount} out of ${total} directional signals are BULLISH (${bullishPercent.toFixed(0)}%).`;
                    if (bullishPercent >= 75) {
                        recommendation = '🟢 Strong Buy Signal - Multiple indicators confirm upward momentum. Consider long position.';
                    } else {
                        recommendation = '🟢 Moderate Buy Signal - Bullish bias but not all indicators agree. Use proper risk management.';
                    }
                } else if (bearishCount > bullishCount) {
                    overallSentiment = 'bearish';
                    conclusion = `${bearishCount} out of ${total} directional signals are BEARISH (${bearishPercent.toFixed(0)}%).`;
                    if (bearishPercent >= 75) {
                        recommendation = '🔴 Strong Sell Signal - Multiple indicators confirm downward momentum. Consider short position or exit longs.';
                    } else {
                        recommendation = '🔴 Moderate Sell Signal - Bearish bias but not all indicators agree. Use proper risk management.';
                    }
                } else {
                    overallSentiment = 'neutral';
                    conclusion = `Signals are evenly split: ${bullishCount} bullish vs ${bearishCount} bearish.`;
                    recommendation = '⚪ No Clear Direction - Conflicting signals. Wait for confirmation or consider range-trading strategy.';
                }
            }

            return { signals, overallSentiment, conclusion, recommendation, bullishCount, bearishCount };
        }

        // Evaluate workflow logic gates to derive a final boolean decision
        function evaluateWorkflowDecision(latestData) {
            const signalNode = state.nodes.find(n => n.type === 'signal');
            if (!signalNode) return { decision: null };

            // Find upstream node connected to signal input
            const inbound = state.connections.find(c => c.to.nodeId === signalNode.id && c.to.port === 'signal');
            if (!inbound) return { decision: null };

            const memo = new Map();
            const result = getNodeBooleanSignal(inbound.from.nodeId, latestData, memo);
            return { decision: result };
        }

        function getNodeBooleanSignal(nodeId, latestData, memo) {
            if (memo.has(nodeId)) return memo.get(nodeId);
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return null;

            let val = null;
            switch (node.type) {
                case 'rsi': {
                    const r = latestData.rsi;
                    if (r === undefined || r === null) { val = null; }
                    else {
                        const rsiNode = state.nodes.find(n => n.type === 'rsi');
                        const oversold = parseFloat(rsiNode?.configValues?.oversold ?? 30);
                        const overbought = parseFloat(rsiNode?.configValues?.overbought ?? 70);
                        const low = Math.min(oversold, overbought);
                        const high = Math.max(oversold, overbought);
                        if (r < low) val = true; // bullish condition
                        else if (r > high) val = false; // bearish condition
                        else val = 'neutral'; // explicitly neutral
                    }
                    break;
                }
                case 'ema': {
                    const e = latestData.ema, c = latestData.close;
                    if (e === undefined || c === undefined) val = null;
                    else if (c > e) val = true; else if (c < e) val = false; else val = null;
                    break;
                }
                case 'sma': {
                    const s = latestData.sma, c = latestData.close;
                    if (s === undefined || c === undefined) val = null;
                    else if (c > s) val = true; else if (c < s) val = false; else val = null;
                    break;
                }
                case 'sma_cross': {
                    const dir = latestData.sma_cross_dir;
                    const fast = latestData.sma_fast, slow = latestData.sma_slow;
                    if (dir === 'bullish') val = true;
                    else if (dir === 'bearish') val = false;
                    else if (fast != null && slow != null) val = fast > slow; else val = null;
                    break;
                }
                case 'macd': {
                    const h = latestData.macd_hist;
                    if (h === undefined || h === null) val = null; else if (h > 0) val = true; else if (h < 0) val = false; else val = null;
                    break;
                }
                case 'bollinger': {
                    const c = latestData.close, u = latestData.boll_upper, l = latestData.boll_lower;
                    if ([c,u,l].some(x => x === undefined || x === null)) val = null;
                    else if (c < l) val = true; else if (c > u) val = false; else val = null;
                    break;
                }
                case 'vwap': {
                    const v = latestData.vwap, c = latestData.close;
                    if (v === undefined || c === undefined) val = null;
                    else if (c > v) val = true; else if (c < v) val = false; else val = null;
                    break;
                }
                case 'volspike': {
                    const sp = latestData.vol_spike;
                    val = sp === true ? true : null; // directional assumption
                    break;
                }
                case 'stochastic': {
                    const k = latestData.stoch_k;
                    if (k === undefined || k === null) val = null;
                    else if (k < 20) val = true; else if (k > 80) val = false; else val = null;
                    break;
                }
                case 'atr':
                case 'obv': {
                    val = null; // non-directional in this simple model
                    break;
                }
                case 'and': {
                    const inA = state.connections.find(c => c.to.nodeId === node.id && c.to.port === 'signal_a');
                    const inB = state.connections.find(c => c.to.nodeId === node.id && c.to.port === 'signal_b');
                    const a = inA ? getNodeBooleanSignal(inA.from.nodeId, latestData, memo) : null;
                    const b = inB ? getNodeBooleanSignal(inB.from.nodeId, latestData, memo) : null;
                    if (a === false || b === false) val = false;
                    else if (a === true && b === true) val = true;
                    else val = null;
                    break;
                }
                case 'or': {
                    const inA = state.connections.find(c => c.to.nodeId === node.id && c.to.port === 'signal_a');
                    const inB = state.connections.find(c => c.to.nodeId === node.id && c.to.port === 'signal_b');
                    const a = inA ? getNodeBooleanSignal(inA.from.nodeId, latestData, memo) : null;
                    const b = inB ? getNodeBooleanSignal(inB.from.nodeId, latestData, memo) : null;
                    if (a === true || b === true) val = true;
                    else if (a === false && b === false) val = false;
                    else val = null;
                    break;
                }
                case 'not': {
                    const inC = state.connections.find(c => c.to.nodeId === node.id && c.to.port === 'signal');
                    const x = inC ? getNodeBooleanSignal(inC.from.nodeId, latestData, memo) : null;
                    val = (x === true) ? false : (x === false) ? true : null;
                    break;
                }
                default:
                    val = null;
            }
            memo.set(nodeId, val);
            return val;
        }



        // Display combined results from both strategy indicators and workflow evaluation
        function displayCombinedResults(strategyData, workflowData, indicators, symbol, timeframe, days) {
            const { success, final_decision, stop_reason, execution_time_ms, blocks, latest_data } = workflowData;
            const analysis = analyzeSignals(indicators, strategyData.latest);
            try {
                const latestPriceVar = (latest_data && typeof latest_data.price === 'number')
                    ? latest_data.price
                    : (latest_data && typeof latest_data.close === 'number')
                        ? latest_data.close
                        : (strategyData && strategyData.latest && typeof strategyData.latest.close === 'number')
                            ? strategyData.latest.close
                            : null;
                if (window.vars) {
                    window.vars.setMany({
                        symbol,
                        timeframe,
                        days,
                        currentPrice: latestPriceVar,
                        latestData: latest_data || null,
                        indicators: indicators || null,
                        finalDecision: final_decision,
                        runCompletedAt: new Date().toISOString()
                    });
                }
            } catch(_){}

            // Extract AI agent analyses
            const aiAgentBlocks = blocks.filter(b => b.block_type === 'ai_agent');
            
            // Populate Agent Analysis tab
            const agentContent = document.getElementById('agentContent');
            if (aiAgentBlocks.length > 0) {
                let aiHTML = '';
                aiAgentBlocks.forEach((aiBlock, idx) => {
                    const agentData = aiBlock.data || {};
                    const analysis = agentData.analysis || 'No analysis text';
                    const model = agentData.model || 'unknown';
                    const provider = agentData.provider || 'unknown';
                    const action = agentData.action || 'neutral';
                    const error = agentData.error;
                    
                    let actionColor = '#9ca3af';
                    let actionIcon = '⚪';
                    if (action === 'bullish') {
                        actionColor = '#22c55e';
                        actionIcon = '🟢';
                    } else if (action === 'bearish') {
                        actionColor = '#ef4444';
                        actionIcon = '🔴';
                    }
                    
                    aiHTML += `
                        <div class="output-section" style="border-left: 4px solid ${actionColor};">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                <h4 style="margin: 0;">${actionIcon} AI Agent ${idx + 1}</h4>
                                <div style="font-size: 11px; color: #6b7280; background: rgba(15, 23, 42, 0.6); padding: 6px 12px; border-radius: 20px;">
                                    ${provider} • ${model}
                                </div>
                            </div>
                            ${error ? `
                                <div style="padding: 12px; background: linear-gradient(135deg, rgba(63, 29, 29, 0.8) 0%, rgba(63, 29, 29, 0.4) 100%); border-left: 4px solid #ef4444; border-radius: 8px; margin-bottom: 12px;">
                                    <strong style="color: #ef4444; display: flex; align-items: center; gap: 6px;">
                                        <span style="font-size: 18px;">⚠️</span> Error
                                    </strong>
                                    <p style="color: #fca5a5; font-size: 13px; margin: 8px 0 0 0; line-height: 1.6;">${error}</p>
                                </div>
                            ` : ''}
                            <div class="ai-analysis-card">
                                <div class="ai-analysis-text">${analysis}</div>
                            </div>
                            <div class="ai-meta">
                                <div><strong>Action:</strong> <span style="color: ${actionColor}; font-weight: 700;">${action.toUpperCase()}</span></div>
                                <div><strong>Execution:</strong> ${aiBlock.execution_time_ms.toFixed(0)}ms</div>
                            </div>
                        </div>
                    `;
                });
                agentContent.innerHTML = aiHTML;
            } else {
                agentContent.innerHTML = `
                    <div class="output-section">
                        <h4>No AI Agent blocks</h4>
                        <p class="output-text" style="color: #9ca3af;">Add an AI Agent block to your workflow to see AI-powered analysis here.</p>
                    </div>
                `;
            }
            // Helper: map block type to icon + friendly name
            function getBlockIconAndName(type) {
                const map = {
                    rsi: { icon: '⚡', name: 'RSI' },
                    ema: { icon: '⚡', name: 'EMA' },
                    sma: { icon: '⚡', name: 'SMA' },
                    macd: { icon: '⚡', name: 'MACD' },
                    bollinger: { icon: '⚡', name: 'Bollinger Bands' },
                    vwap: { icon: '⚡', name: 'VWAP' },
                    stochastic: { icon: '⚡', name: 'Stochastic' },
                    obv: { icon: '⚡', name: 'OBV' },
                    trendline: { icon: '⚡', name: 'Trendline' },
                    volspike: { icon: '💧', name: 'Volume Spike' },
                    price_above: { icon: '➕', name: 'Price Above' },
                    price_below: { icon: '➕', name: 'Price Below' },
                    ai_agent: { icon: '🤖', name: 'AI Agent' },
                    alpaca_config: { icon: '🧰', name: 'Alpaca Config' },
                    symbol: { icon: '🔤', name: 'Symbol' },
                    timeframe: { icon: '🕒', name: 'Timeframe' },
                    lookback: { icon: '📅', name: 'Lookback' },
                    input: { icon: '🧩', name: 'Input' },
                    signal: { icon: '🧩', name: 'Signal' }
                };
                return map[type] || { icon: '🧩', name: type };
            }

            // Build Execution Summary section
            const ts = (workflowData.historical_bars && workflowData.historical_bars.timestamps) || [];
            const startTs = ts.length ? new Date(ts[0]) : null;
            const endTs = ts.length ? new Date(ts[ts.length - 1]) : null;
            const startLabel = startTs ? startTs.toLocaleString() : 'N/A';
            const endLabel = endTs ? endTs.toLocaleString() : 'N/A';
            const statusText = success ? 'Completed' : `Stopped: ${stop_reason || 'Unknown reason'}`;
            const statusColor = success ? '#22c55e' : '#ef4444';

            let resultHTML = '';
            resultHTML += `
                <div class="output-section">
                    <h4>Execution Summary</h4>
                    <div class="stats-grid" style="margin-top: 8px;">
                        <div class="data-card"><div class="data-card-header"><span>🔤</span> Symbol</div><div class="data-card-value">${symbol}</div></div>
                        <div class="data-card"><div class="data-card-header"><span>🕒</span> Timeframe</div><div class="data-card-value">${timeframe}</div></div>
                        <div class="data-card"><div class="data-card-header"><span>📅</span> Lookback</div><div class="data-card-value">${days}d</div></div>
                        <div class="data-card"><div class="data-card-header"><span>📊</span> Candles</div><div class="data-card-value">${workflowData.bar_count || strategyData.bar_count || 0}</div></div>
                        <div class="data-card"><div class="data-card-header"><span>🟢</span> Start</div><div class="data-card-value" title="${startLabel}">${startLabel}</div></div>
                        <div class="data-card"><div class="data-card-header"><span>🔚</span> End</div><div class="data-card-value" title="${endLabel}">${endLabel}</div></div>
                    </div>
                    <div style="margin-top: 12px; font-size: 13px; color: ${statusColor};">${statusText}</div>
                </div>
            `;

            // Block-by-Block Results
            resultHTML += `
                <div class="output-section">
                    <h4>Block-by-Block Results</h4>
                    <div style="margin-top: 12px;">
            `;

            blocks.forEach((block, idx) => {
                let col = '#9ca3af';
                let ico = '⚪';
                if (block.status === 'passed') { col = '#22c55e'; ico = '✅'; }
                else if (block.status === 'failed') { col = '#ef4444'; ico = '❌'; }
                else if (block.status === 'skipped') { col = '#9ca3af'; ico = '⏭️'; }
                const meta = getBlockIconAndName(block.block_type);
                const title = `${meta.icon} ${meta.name}`;
                const keyOutput = (block.data && typeof block.data.condition_met !== 'undefined') ? `Condition Met: ${block.data.condition_met ? 'Yes' : 'No'}` : '';
                resultHTML += `
                    <div class="block-exec-card" style="border-left-color:${col};">
                        <div class="block-exec-header">
                            <span class="block-exec-icon">${ico}</span>
                            <span class="block-exec-title">${idx + 1}. ${title}</span>
                            <span class="block-exec-time">${(block.execution_time_ms||0).toFixed(1)}ms</span>
                        </div>
                        ${keyOutput ? `<div class="metric-label" style="color:${col}; margin:4px 0 2px 0;">${keyOutput}</div>` : ''}
                        <p class="block-exec-message" style="color:${col};">${block.message || ''}</p>
                    </div>
                `;
            });
            resultHTML += `</div></div>`;

            // Final Strategy Output with signal direction and price
            const decisionColor = success ? '#22c55e' : '#ef4444';
            const decisionIcon = success ? '✅' : '❌';
            let finalDecisionText = final_decision;
            
            // Determine signal direction for confirmed strategies
            if (success && final_decision === 'CONFIRMED') {
                const latestPrice = latest_data?.price || latest_data?.close || strategyData?.latest?.close || 0;
                // Use the already-computed analysis from the beginning of this function
                const { bullishCount, bearishCount } = analysis;
                
                console.log('Signal direction analysis:', { bullishCount, bearishCount, latestPrice, indicators, latest_data });
                
                if (bullishCount > bearishCount) {
                    finalDecisionText = `Confirmed Bullish Signal<br/><span style="font-size:16px;font-weight:600;color:#22c55e;">BUY @ $${latestPrice.toFixed(2)}</span>`;
                } else if (bearishCount > bullishCount) {
                    finalDecisionText = `Confirmed Bearish Signal<br/><span style="font-size:16px;font-weight:600;color:#ef4444;">SELL @ $${latestPrice.toFixed(2)}</span>`;
                } else {
                    finalDecisionText = `Confirmed Signal<br/><span style="font-size:14px;color:#9ca3af;">@ $${latestPrice.toFixed(2)}</span>`;
                }

                // Update the Latest Confirmed Signal section at the very top
                const latestBox = document.getElementById('latestSignalBox');
                if (latestBox) {
                    let accent = '#22c55e';
                    let title = 'Confirmed Signal';
                    let actionLine = `@ $${latestPrice.toFixed(2)}`;
                    if (bullishCount > bearishCount) { accent = '#22c55e'; title = 'Confirmed Bullish Signal'; actionLine = `BUY @ $${latestPrice.toFixed(2)}`; }
                    else if (bearishCount > bullishCount) { accent = '#ef4444'; title = 'Confirmed Bearish Signal'; actionLine = `SELL @ $${latestPrice.toFixed(2)}`; }
                    const currentSymbol = (typeof safeGetCurrentSymbol === 'function' ? safeGetCurrentSymbol() : (typeof getCurrentSymbol === 'function' ? getCurrentSymbol() : (typeof window.getCurrentSymbol === 'function' ? window.getCurrentSymbol() : null))) || 'N/A';
                    latestBox.innerHTML = `
                        <div class="output-section" style="border-left: 4px solid ${accent};">
                            <div style="display:flex;align-items:center;gap:12px;">
                                <span style="font-size:24px;">${bullishCount > bearishCount ? '🟢' : (bearishCount > bullishCount ? '🔴' : '⚪')}</span>
                                <div>
                                    <div style="font-size:18px;font-weight:700;color:${accent};">${title}</div>
                                    <div style="font-size:14px;color:${accent};font-weight:600;">${currentSymbol} ${actionLine}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else {
                // If not confirmed, clear or show placeholder in Latest Confirmed Signal section
                const latestBox = document.getElementById('latestSignalBox');
                if (latestBox) {
                    latestBox.innerHTML = `<div class="output-text" style="color:#9ca3af;">No confirmed signal yet. Run your workflow to see the latest decision here.</div>`;
                }
            }
            
            resultHTML += `
                <div class="output-section" style="border-left: 4px solid ${decisionColor};">
                    <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px;">
                        <span style="font-size:28px;">${decisionIcon}</span>
                        <div style="flex:1;">
                            <h4 style="margin:0;">Final Strategy Output</h4>
                            <div style="font-size:20px;font-weight:700;color:${decisionColor};line-height:1.4;">${finalDecisionText}</div>
                        </div>
                    </div>
                    ${!success && stop_reason ? `<div class="output-text" style="color:#e5e7eb;">Reason: ${stop_reason}</div>` : ''}
                    <div style="display:flex;gap:16px;margin-top:10px;">
                        <div class="metric-card"><div class="metric-label">Execution Time</div><div class="metric-value" style="color:#60a5fa;">${execution_time_ms.toFixed(0)}ms</div></div>
                        <div class="metric-card"><div class="metric-label">Blocks Processed</div><div class="metric-value" style="color:#a78bfa;">${blocks.length}</div></div>
                    </div>
                </div>
            `;

            // AI Explanation (summary)
            if (aiAgentBlocks.length > 0) {
                const first = aiAgentBlocks[0];
                const a = (first.data && first.data.analysis) ? String(first.data.analysis) : '';
                const snippet = a.length > 600 ? a.slice(0, 600) + '…' : a;
                let action = (first.data && first.data.action) ? String(first.data.action) : 'neutral';
                let actionColor = '#9ca3af';
                if (action === 'bullish') actionColor = '#22c55e';
                if (action === 'bearish') actionColor = '#ef4444';
                resultHTML += `
                    <div class="output-section">
                        <h4>AI Explanation</h4>
                        <div class="ai-analysis-card">
                            <div class="ai-analysis-text">${snippet || 'No AI analysis text available.'}</div>
                        </div>
                        <div class="ai-meta" style="margin-top:8px;">
                            <div><strong>Action:</strong> <span style="color:${actionColor};font-weight:700;">${action.toUpperCase()}</span></div>
                            <div style="color:#9ca3af; font-size:12px; margin-top:6px;">View the Agent Analysis tab for the full write-up.</div>
                        </div>
                    </div>
                `;
            }

            // Single-line Performance Chart
            resultHTML += `
                <div class="output-section">
                    <h4>📈 Performance</h4>
                    <div class="strategy-chart-container">
                        <canvas id="strategyPerformanceChart"></canvas>
                        <div class="chart-tooltip" id="chartTooltip"></div>
                    </div>
                </div>
            `;

            // Render workflow results exclusively in insights panel (moved from legacy output panel)
            outputContent.innerHTML = '';
            const aiBox = document.getElementById('aiAnalysisBox');
            if (aiBox) {
                aiBox.innerHTML += `<div class="workflow-results" style="margin-top:16px;">${resultHTML}</div>`;
            }

            // Update premium results panel with live insights
            try {
                const latestPrice = (workflowData && workflowData.latest_data && typeof workflowData.latest_data.price === 'number')
                    ? workflowData.latest_data.price
                    : (workflowData && workflowData.latest_data && typeof workflowData.latest_data.close === 'number')
                        ? workflowData.latest_data.close
                        : (strategyData && strategyData.latest && typeof strategyData.latest.close === 'number')
                            ? strategyData.latest.close
                            : 0;

                if (window.vars) {
                    window.vars.set('currentPrice', latestPrice);
                }

                // Use AI agent output if available; otherwise show heuristic analysis
                if (aiAgentBlocks.length > 0 && typeof updateAIAnalysisWithAgentOutput === 'function') {
                    updateAIAnalysisWithAgentOutput(workflowData, latestPrice, aiAgentBlocks);
                } else if (typeof updateAIAnalysis === 'function') {
                    updateAIAnalysis(workflowData, latestPrice);
                }

                // Add to signal history when a final decision is produced
                if (workflowData && workflowData.success && workflowData.final_decision && typeof addSignalToHistory === 'function') {
                    // Determine last meaningful condition block (exclude AI and config blocks)
                    const skipTypes = ['ai_agent','alpaca_config','input','symbol','timeframe','lookback','signal'];
                    const condBlocks = Array.isArray(blocks) ? blocks.filter(b => !skipTypes.includes(b.block_type)) : [];
                    let triggerBlockType = 'Final Block';
                    if (success) {
                        const lastPassed = [...condBlocks].reverse().find(b => b.status === 'passed');
                        triggerBlockType = lastPassed ? lastPassed.block_type : (condBlocks.length ? condBlocks[condBlocks.length - 1].block_type : 'Final Block');
                    } else {
                        const firstFailed = condBlocks.find(b => b.status === 'failed');
                        triggerBlockType = firstFailed ? firstFailed.block_type : triggerBlockType;
                    }
                    const triggerMeta = getBlockIconAndName(triggerBlockType);
                    const triggerLabel = triggerMeta.name;
                    
                    // Determine signal direction
                    let signalType = 'CONFIRMED';
                    let signalLabel = 'Confirmed Signal';
                    if (workflowData.final_decision === 'CONFIRMED') {
                        const signalAnalysis = analyzeSignals(indicators, strategyData.latest || workflowData.latest_data || {});
                        const { bullishCount, bearishCount } = signalAnalysis;
                        if (bullishCount > bearishCount) {
                            signalType = 'BUY';
                            signalLabel = 'Confirmed Bullish Signal';
                        } else if (bearishCount > bullishCount) {
                            signalType = 'SELL';
                            signalLabel = 'Confirmed Bearish Signal';
                        } else {
                            signalType = 'NEUTRAL';
                            signalLabel = 'Confirmed Neutral Signal';
                        }
                    }
                    
                    console.log('displayCombinedResults: will add signal to history', { final_decision: workflowData.final_decision, success: workflowData.success, latestPrice, trigger: triggerLabel });
                    try { if (typeof addSignalToHistory !== 'function') console.warn('addSignalToHistory not defined'); } catch(_){}
                    addSignalToHistory({
                        timestamp: new Date().toISOString(),
                        type: signalType,
                        label: signalLabel,
                        price: latestPrice || 0,
                        trigger: triggerLabel
                    });

                    // Auto-open insights on first recorded signal
                    const panel = document.getElementById('resultsPanel');
                    if (panel && window.signalHistory && window.signalHistory.length === 1 && !panel.classList.contains('open')) {
                        setTimeout(() => { if (typeof toggleResultsPanel === 'function') toggleResultsPanel(); }, 300);
                    }
                }
            } catch (e) {
                console.warn('Insights panel update failed:', e);
            }

            // Initialize the strategy performance chart in simple mode after DOM is ready
            setTimeout(() => {
                if (typeof window.initializeStrategyChart === 'function') {
                    // enable simple single-line mode
                    if (window.chartState) { window.chartState.simple = true; }
                    window.initializeStrategyChart(workflowData, analysis, symbol, timeframe, days);
                } else {
                    console.error('❌ initializeStrategyChart function not found');
                }
            }, 100);
        }


        // Display results in output panel
        function displayResults(data, indicators, symbol, timeframe, days) {
            const analysis = analyzeSignals(indicators, data.latest);
            const logic = evaluateWorkflowDecision(data.latest);
            if (logic.decision !== null) {
                const decided = logic.decision ? 'bullish' : 'bearish';
                analysis.overallSentiment = decided;
                analysis.conclusion = `Logic gates resolved to ${decided.toUpperCase()} decision.`;
                analysis.recommendation = decided === 'bullish' ? '🟢 Logic output: consider long bias.' : '🔴 Logic output: consider short/hedge.';
            }
            
            let html = `
                <div class="output-section">
                    <h4>📋 Workflow Execution Order</h4>
            `;

            // Show execution order based on connections
            const executionOrder = getExecutionOrder();
            executionOrder.forEach((nodeId, index) => {
                const node = state.nodes.find(n => n.id === nodeId);
                if (node && node.type !== 'input') {
                    html += `
                        <div class="step-indicator">
                            <div class="step-number">${index}</div>
                            <div class="step-name">${node.def.name}</div>
                            <div class="step-result">✓</div>
                        </div>
                    `;
                }
            });

            html += `</div>`;

            // Strategy Performance Chart
            html += `
                <div class="output-section">
                    <h4>📈 Strategy Performance Over Time</h4>
                    <div class="chart-controls">
                        <div class="chart-control-group">
                            <span class="chart-control-label">Time Period</span>
                            <div style="display: flex; gap: 6px;">
                                <button class="chart-period-btn" data-period="7" onclick="updateChartPeriod(7)">7D</button>
                                <button class="chart-period-btn active" data-period="30" onclick="updateChartPeriod(30)">30D</button>
                                <button class="chart-period-btn" data-period="90" onclick="updateChartPeriod(90)">90D</button>
                                <button class="chart-period-btn" data-period="180" onclick="updateChartPeriod(180)">6M</button>
                                <button class="chart-period-btn" data-period="365" onclick="updateChartPeriod(365)">1Y</button>
                            </div>
                        </div>
                        <button class="chart-expand-btn" onclick="expandStrategyChart()" title="Expand chart">
                            ⤢ Expand
                        </button>
                    </div>
                    <div class="chart-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #10b981; width: 20px; height: 20px; border-radius: 3px;"></div>
                            <span>Bullish Periods</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ef4444; width: 20px; height: 20px; border-radius: 3px;"></div>
                            <span>Bearish Periods</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #6b7280; width: 20px; height: 20px; border-radius: 3px;"></div>
                            <span>Neutral/No Signal</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #60a5fa;"></div>
                            <span>Strategy Strength</span>
                        </div>
                    </div>
                    <div class="strategy-chart-container">
                        <canvas id="strategyPerformanceChart"></canvas>
                        <div class="chart-tooltip" id="chartTooltip"></div>
                    </div>
                </div>
            `;

            // Market data summary
            html += `
                <div class="output-section">
                    <h4>📊 Market Data</h4>
                    <p class="output-text">
                        Symbol: <strong>${symbol}</strong><br>
                        Timeframe: <strong>${timeframe}</strong><br>
                        Lookback: <strong>${days} days</strong><br>
                        Latest Close: <strong>$${data.latest.close.toFixed(2)}</strong><br>
                        Bars Analyzed: <strong>${data.bar_count}</strong>
                    </p>
                </div>
            `;

            // Individual indicator signals
            html += `
                <div class="output-section">
                    <h4>🎯 Indicator Signals (In Order)</h4>
            `;

            analysis.signals.forEach((sig, idx) => {
                html += `
                    <div style="margin-bottom: 12px; padding: 10px; background: #2d3239; border-radius: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                            <span style="color: #60a5fa; font-weight: 600; font-size: 12px;">STEP ${idx + 1}</span>
                            <span class="signal-badge ${sig.sentiment}">
                                ${sig.sentiment.toUpperCase()}
                            </span>
                            <strong style="font-size: 13px;">${sig.name.toUpperCase()}</strong>
                        </div>
                        <p class="output-text" style="font-size: 12px; margin: 0; color: #9ca3af;">
                            ${sig.reason}
                        </p>
                    </div>
                `;
            });

            html += `</div>`;

            // Overall conclusion
            html += `
                <div class="output-section">
                    <h4>💡 Strategy Conclusion</h4>
                    <div class="conclusion-box ${analysis.overallSentiment}">
                        <div class="conclusion-title" style="color: ${analysis.overallSentiment === 'bullish' ? '#10b981' : analysis.overallSentiment === 'bearish' ? '#ef4444' : '#9ca3af'}">
                            ${analysis.overallSentiment.toUpperCase()} SIGNAL
                        </div>
                        <p class="conclusion-text">
                            ${analysis.conclusion}<br><br>
                            <strong>${analysis.recommendation}</strong>
                        </p>
                    </div>
                </div>
            `;

            // Signal strength meter
            const totalSignals = analysis.bullishCount + analysis.bearishCount;
            const bullishPercent = totalSignals > 0 ? (analysis.bullishCount / totalSignals * 100) : 50;
            
            html += `
                <div class="output-section">
                    <h4>📈 Signal Strength</h4>
                    <div style="margin-top: 10px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px;">
                            <span style="color: #10b981;">Bullish: ${analysis.bullishCount}</span>
                            <span style="color: #ef4444;">Bearish: ${analysis.bearishCount}</span>
                        </div>
                        <div style="width: 100%; height: 20px; background: #2d3239; border-radius: 10px; overflow: hidden; display: flex;">
                            <div style="width: ${bullishPercent}%; background: linear-gradient(90deg, #10b981, #34d399); height: 100%;"></div>
                            <div style="width: ${100 - bullishPercent}%; background: linear-gradient(90deg, #f87171, #ef4444); height: 100%;"></div>
                        </div>
                    </div>
                </div>
            `;

            outputContent.innerHTML = html;
            
            // Initialize chart after DOM is ready
            setTimeout(() => {
                if (window.chartState) { window.chartState.simple = false; }
                initializeStrategyChart(data, analysis, symbol, timeframe, days);
            }, 0);
        }

        // Strategy Performance Chart System
        let chartState = {
            period: 30, // days
            data: null,
            analysis: null,
            symbol: '',
            timeframe: '',
            canvas: null,
            ctx: null,
            simple: false
        };

        function initializeStrategyChart(data, analysis, symbol, timeframe, days) {
            let canvas = document.getElementById('strategyPerformanceChart');
            if (!canvas) {
                // Try to create the canvas dynamically inside the strategy chart container
                const container = document.querySelector('.strategy-chart-container');
                if (container) {
                    canvas = document.createElement('canvas');
                    canvas.id = 'strategyPerformanceChart';
                    container.insertBefore(canvas, container.firstChild);
                    console.warn('initializeStrategyChart: Created missing canvas#strategyPerformanceChart dynamically');
                } else {
                    console.error('initializeStrategyChart: Canvas element not found and no .strategy-chart-container available');
                    return;
                }
            }

            console.log('📊 Initializing strategy chart...');
            console.log('Strategy performance data:', data.strategy_performance);
            
            chartState.data = data;
            chartState.analysis = analysis;
            chartState.symbol = symbol;
            chartState.timeframe = timeframe;
            chartState.canvas = canvas;
            chartState.ctx = canvas.getContext('2d');
            
            // Store strategy performance data
            chartState.strategyPerformance = data.strategy_performance || [];
            console.log(`📈 Loaded ${chartState.strategyPerformance.length} performance data points`);

            // Set canvas size
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            console.log(`📐 Canvas size: ${canvas.width}x${canvas.height}`);

            // Generate chart data from strategy performance
            generateChartData(chartState.period);
            console.log(`📊 Generated ${chartState.historicalData?.length || 0} chart points`);
            
            drawStrategyChart();

            // Mouse events for tooltip
            canvas.addEventListener('mousemove', handleChartHover);
            canvas.addEventListener('mouseleave', hideChartTooltip);
        }

        function updateChartPeriod(days) {
            chartState.period = days;
            
            // Update active button
            document.querySelectorAll('.chart-period-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.period) === days);
            });

            // Regenerate and redraw
            generateChartData(days);
            drawStrategyChart();
        }

        function generateChartData(days) {
            console.log(`📊 generateChartData called for ${days} days`);
            
            // Use real strategy performance data from backend
            if (!chartState.strategyPerformance || chartState.strategyPerformance.length === 0) {
                console.warn('⚠️ No strategy performance data available');
                chartState.historicalData = [];
                return;
            }
            
            const perfData = chartState.strategyPerformance;
            console.log(`📈 Processing ${perfData.length} performance data points`);
            
            // Calculate how many bars to show based on selected period
            const barsToShow = Math.min(perfData.length, Math.ceil(days * 6.5)); // ~6.5 trading hours per day
            const startIdx = Math.max(0, perfData.length - barsToShow);
            console.log(`[chart] Showing bars from index ${startIdx} to ${perfData.length - 1}`);
            
            // Build historical data array from strategy performance
            const historicalData = [];
            
            for (let i = startIdx; i < perfData.length; i++) {
                const perf = perfData[i];
                
                if (!perf) {
                    console.warn(`⚠️ Missing performance data at index ${i}`);
                    continue;
                }
                
                // Parse timestamp
                let timestamp;
                if (typeof perf.timestamp === 'number') {
                    timestamp = perf.timestamp;
                } else if (typeof perf.timestamp === 'string') {
                    timestamp = new Date(perf.timestamp).getTime();
                } else {
                    timestamp = Date.now() - (perfData.length - i) * 3600000;
                }
                
                // Calculate strategy strength (0-100 scale)
                let strength = 50; // neutral default
                if (perf.sentiment === 'bullish') {
                    strength = 70 + Math.random() * 25; // 70-95
                } else if (perf.sentiment === 'bearish') {
                    strength = 5 + Math.random() * 25; // 5-30
                } else {
                    strength = 40 + Math.random() * 20; // 40-60
                }
                
                historicalData.push({
                    timestamp,
                    strength,
                    sentiment: perf.sentiment || 'neutral',
                    decision: perf.decision,
                    success: perf.success,
                    close: perf.close || 0,
                    index: i
                });
            }
            
            console.log(`✅ Generated ${historicalData.length} chart data points`);
            chartState.historicalData = historicalData;
        }

        function drawStrategyChart() {
            const { ctx, canvas, historicalData } = chartState;
            
            console.log('🎨 drawStrategyChart called');
            console.log('Canvas:', canvas);
            console.log('Context:', ctx);
            console.log('Data points:', historicalData?.length);
            
            if (!ctx || !canvas || !historicalData || historicalData.length === 0) {
                console.error('❌ Cannot draw chart - missing required data');
                if (!ctx) console.error('  - No canvas context');
                if (!canvas) console.error('  - No canvas element');
                if (!historicalData || historicalData.length === 0) console.error('  - No historical data');
                return;
            }
            
            const w = canvas.width;
            const h = canvas.height;
            
            console.log(`[chart] Drawing canvas ${w}x${h} with ${historicalData.length} points`);
            
            // Clear
            ctx.clearRect(0, 0, w, h);
            
            // Background first
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, w, h);
            
            // If no data, show message
            if (historicalData.length === 0) {
                ctx.fillStyle = '#9ca3af';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No strategy performance data available', w / 2, h / 2);
                console.log('⚠️ No data to display');
                return;
            }
            
            const pad = { l: 60, r: 30, t: 30, b: 50 };
            const chartW = w - pad.l - pad.r;
            const chartH = h - pad.t - pad.b;
            
            // Background
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, w, h);
            
            // Scales
            const xScale = i => pad.l + (i / (historicalData.length - 1)) * chartW;
            const yScale = strength => pad.t + chartH - ((strength / 100) * chartH);
            
            // Grid
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 1;
            
            // Horizontal grid lines (0-100 scale)
            const gridLines = 5;
            for (let i = 0; i <= gridLines; i++) {
                const y = pad.t + (i / gridLines) * chartH;
                ctx.beginPath();
                ctx.moveTo(pad.l, y);
                ctx.lineTo(w - pad.r, y);
                ctx.stroke();
                
                // Y-axis labels
                const value = 100 - (i / gridLines) * 100;
                ctx.fillStyle = '#6b7280';
                ctx.font = '11px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(0), pad.l - 8, y + 4);
            }
            
            if (!chartState.simple) {
                // Background zones
                ctx.fillStyle = 'rgba(16, 185, 129, 0.08)'; // Bullish zone
                ctx.fillRect(pad.l, pad.t, chartW, chartH * 0.3);
                
                ctx.fillStyle = 'rgba(239, 68, 68, 0.08)'; // Bearish zone
                ctx.fillRect(pad.l, pad.t + chartH * 0.7, chartW, chartH * 0.3);
                
                // Threshold lines
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(pad.l, yScale(70));
                ctx.lineTo(w - pad.r, yScale(70));
                ctx.stroke();
                
                ctx.strokeStyle = '#ef4444';
                ctx.beginPath();
                ctx.moveTo(pad.l, yScale(30));
                ctx.lineTo(w - pad.r, yScale(30));
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Vertical grid lines (time)
            const timeGridLines = 8;
            for (let i = 0; i <= timeGridLines; i++) {
                const x = pad.l + (i / timeGridLines) * chartW;
                ctx.beginPath();
                ctx.moveTo(x, pad.t);
                ctx.lineTo(x, h - pad.b);
                ctx.strokeStyle = '#1f2937';
                ctx.stroke();
                
                // X-axis time labels
                const dataIdx = Math.floor((i / timeGridLines) * (historicalData.length - 1));
                if (historicalData[dataIdx]) {
                    const date = new Date(historicalData[dataIdx].timestamp);
                    const label = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    ctx.fillStyle = '#6b7280';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(label, x, h - pad.b + 15);
                }
            }
            
            if (!chartState.simple) {
                // Draw bars showing strategy sentiment
                const barWidth = Math.max(3, chartW / historicalData.length * 0.8);
                historicalData.forEach((d, i) => {
                    const x = xScale(i);
                    const y = yScale(d.strength);
                    const barHeight = (h - pad.b) - y;
                    let color;
                    if (d.sentiment === 'bullish') color = '#10b981';
                    else if (d.sentiment === 'bearish') color = '#ef4444';
                    else color = '#6b7280';
                    ctx.fillStyle = color;
                    ctx.fillRect(x - barWidth/2, y, barWidth, barHeight);
                });
            }
            
            // Draw strategy strength line
            ctx.beginPath();
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = chartState.simple ? 2 : 2.5;
            ctx.shadowColor = chartState.simple ? 'transparent' : '#60a5fa';
            ctx.shadowBlur = chartState.simple ? 0 : 6;
            
            historicalData.forEach((d, i) => {
                const x = xScale(i);
                const y = yScale(d.strength);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            if (!chartState.simple) {
                // Draw points on line
                historicalData.forEach((d, i) => {
                    const x = xScale(i);
                    const y = yScale(d.strength);
                    let dotColor;
                    if (d.sentiment === 'bullish') dotColor = '#10b981';
                    else if (d.sentiment === 'bearish') dotColor = '#ef4444';
                    else dotColor = '#6b7280';
                    ctx.fillStyle = dotColor + '40';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = dotColor;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            if (!chartState.simple) {
                // Current position marker
                const lastIdx = historicalData.length - 1;
                const lastX = xScale(lastIdx);
                const lastY = yScale(historicalData[lastIdx].strength);
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(lastX, lastY, 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = '#f59e0b';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Axis labels
            if (!chartState.simple) {
                ctx.fillStyle = '#e5e7eb';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Strategy Performance - ' + chartState.symbol, w / 2, 18);
                ctx.save();
                ctx.translate(15, h / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText('Strategy Strength', 0, 0);
                ctx.restore();
                ctx.textAlign = 'center';
                ctx.fillText('Time', w / 2, h - 5);
            }
            
            // Store scaled data for hover
            chartState.scaledData = historicalData.map((d, i) => ({
                ...d,
                x: xScale(i),
                y: yScale(d.strength)
            }));
        }

        function handleChartHover(e) {
            const canvas = chartState.canvas;
            const tooltip = document.getElementById('chartTooltip');
            if (!canvas || !tooltip || !chartState.scaledData) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Find nearest data point
            let nearest = null;
            let minDist = Infinity;
            
            chartState.scaledData.forEach(d => {
                const dist = Math.abs(d.x - mouseX);
                if (dist < minDist && dist < 30) {
                    minDist = dist;
                    nearest = d;
                }
            });
            
            if (nearest) {
                const date = new Date(nearest.timestamp).toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                let sentimentBadge = '';
                let sentimentColor = '#6b7280';
                if (nearest.sentiment === 'bullish') {
                    sentimentBadge = '🔼 BULLISH';
                    sentimentColor = '#10b981';
                } else if (nearest.sentiment === 'bearish') {
                    sentimentBadge = '🔽 BEARISH';
                    sentimentColor = '#ef4444';
                } else {
                    sentimentBadge = '➖ NEUTRAL';
                }
                
                tooltip.innerHTML = `
                    <div style="font-weight: 600; color: ${sentimentColor};">${sentimentBadge}</div>
                    <div style="color: #9ca3af; font-size: 10px; margin-top: 2px;">${date}</div>
                    <div style="margin-top: 4px; color: #e5e7eb; font-size: 11px;">Strength: ${nearest.strength.toFixed(1)}</div>
                    <div style="margin-top: 2px; color: #9ca3af; font-size: 10px;">Price: $${nearest.close.toFixed(2)}</div>
                `;
                
                tooltip.style.left = Math.min(rect.width - 160, Math.max(10, e.clientX - rect.left + 15)) + 'px';
                tooltip.style.top = Math.max(10, e.clientY - rect.top - 20) + 'px';
                tooltip.style.display = 'block';
            } else {
                tooltip.style.display = 'none';
            }
        }

        function hideChartTooltip() {
            const tooltip = document.getElementById('chartTooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        function expandStrategyChart() {
            // Create fullscreen overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
            overlay.style.background = 'rgba(0, 0, 0, 0.95)';
            overlay.style.zIndex = '5000';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.padding = '40px';
            
            const container = document.createElement('div');
            container.style.width = '100%';
            container.style.height = '100%';
            container.style.maxWidth = '1600px';
            container.style.position = 'relative';
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            
            const header = document.createElement('div');
            header.style.display = 'flex';
            header.style.justifyContent = 'space-between';
            header.style.alignItems = 'center';
            header.style.marginBottom = '20px';
            header.innerHTML = `
                <h3 style="color: #e5e7eb; margin: 0; font-size: 20px;">📈 ${chartState.symbol} - Strategy Performance</h3>
                <button onclick="this.closest('[style*=fixed]').remove()" style="background: #374151; border: 1px solid #4b5563; color: #e5e7eb; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">✕ Close</button>
            `;
            
            const chartDiv = document.createElement('div');
            chartDiv.style.flex = '1';
            chartDiv.style.position = 'relative';
            chartDiv.style.background = '#0f1419';
            chartDiv.style.borderRadius = '8px';
            chartDiv.style.border = '1px solid #2d3239';
            
            const canvas = document.createElement('canvas');
            canvas.id = 'expandedChart';
            canvas.width = 1400;
            canvas.height = 700;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            chartDiv.appendChild(canvas);
            container.appendChild(header);
            container.appendChild(chartDiv);
            overlay.appendChild(container);
            document.body.appendChild(overlay);
            
            // Draw expanded chart
            const ctx = canvas.getContext('2d');
            const tempCanvas = chartState.canvas;
            const tempCtx = chartState.ctx;
            chartState.canvas = canvas;
            chartState.ctx = ctx;
            drawStrategyChart();
            chartState.canvas = tempCanvas;
            chartState.ctx = tempCtx;
        }

        // Get execution order based on connections (topological sort)
        function getExecutionOrder() {
            const order = [];
            const visited = new Set();
            
            // Find input node
            const inputNode = state.nodes.find(n => n.type === 'input');
            if (!inputNode) return order;
            
            order.push(inputNode.id);
            visited.add(inputNode.id);
            
            // BFS to get connected nodes in order
            const queue = [inputNode.id];
            
            while (queue.length > 0) {
                const currentId = queue.shift();
                
                // Find all connections from this node
                state.connections.forEach(conn => {
                    if (conn.from.nodeId === currentId && !visited.has(conn.to.nodeId)) {
                        order.push(conn.to.nodeId);
                        visited.add(conn.to.nodeId);
                        queue.push(conn.to.nodeId);
                    }
                });
            }
            
            return order;
        }

        // Mock data for testing without backend
        async function mockExecute(symbol, timeframe, days, indicators) {
            // Simulate API delay
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            return {
                bar_count: 45,
                latest: {
                    close: 672.95,
                    rsi: 45.23,
                    ema: 670.12,
                    macd_line: 1.23,
                    macd_signal: 0.98,
                    macd_hist: 0.25,
                    vwap: 671.50,
                    vol_spike: false,
                    boll_upper: 680.50,
                    boll_lower: 665.30,
                    atr: 5.67,
                    stoch_k: 52.34,
                    stoch_d: 48.90
                }
            };
        }

        // Test with mock data button (for development)
        window.testWithMockData = function() {
            outputPanel.classList.add('open');
            const mockData = {
                bar_count: 45,
                latest: {
                    close: 672.95,
                    rsi: 28.5,
                    ema: 670.12,
                    macd_hist: 0.85,
                    vwap: 668.50,
                    vol_spike: true
                }
            };
            displayResults(mockData, ['rsi', 'ema', 'macd', 'vwap', 'volspike'], 'SPY', '1Hour', 7);
        };

        // Add keyboard shortcut info
        console.log('💡 Tip: Press Escape to cancel connection drawing');
        console.log('💡 Tip: Ctrl+S to quick save, Ctrl+O to quick load');
        console.log('💡 Test output panel: testWithMockData()');

        // Auto-save to localStorage every 30 seconds
        setInterval(() => {
            if (state.nodes.length > 0) {
                const workflow = {
                    version: '1.0',
                    nodes: state.nodes.map(n => ({
                        id: n.id,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        configValue: n.configValue,
                        configValues: n.configValues
                    })),
                    connections: state.connections
                };
                localStorage.setItem('workflow_autosave', JSON.stringify(workflow));
                console.log('💾 Auto-saved workflow');
            }
        }, 30000);

        // Keyboard shortcuts for quick save/load
        document.addEventListener('keydown', (e) => {
            // Ctrl+S or Cmd+S: Quick save to localStorage
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                const workflow = {
                    version: '1.0',
                    nodes: state.nodes.map(n => ({
                        id: n.id,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        configValue: n.configValue,
                        configValues: n.configValues
                    })),
                    connections: state.connections
                };
                localStorage.setItem('workflow_quicksave', JSON.stringify(workflow));
                
                // Visual feedback
                const btn = document.getElementById('exportBtn');
                const originalText = btn.textContent;
                btn.textContent = '✅ Saved';
                btn.style.background = '#22c55e';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 1000);
            }
            
            // Ctrl+O or Cmd+O: Quick load from localStorage
            if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                e.preventDefault();
                const saved = localStorage.getItem('workflow_quicksave');
                if (!saved) {
                    alert('⚠️ No quick-saved workflow found. Use Ctrl+S to save first.');
                    return;
                }
                
                try {
                    const workflow = JSON.parse(saved);
                    
                    // Clear existing
                    state.nodes = [];
                    state.connections = [];
                    canvas.innerHTML = '';
                    connectionLayer.innerHTML = '';
                    
                    // Restore nodes
                    const idMap = {};
                    workflow.nodes.forEach((nodeData) => {
                        const def = blockDefs[nodeData.type];
                        if (!def) return;
                        
                        const node = {
                            id: state.nextNodeId++,
                            type: nodeData.type,
                            x: nodeData.x,
                            y: nodeData.y,
                            def: def
                        };
                        
                        if (nodeData.configValue !== undefined) node.configValue = nodeData.configValue;
                        if (nodeData.configValues) node.configValues = { ...nodeData.configValues };
                        
                        state.nodes.push(node);
                        idMap[nodeData.id] = node.id;
                        renderNode(node);
                    });
                    
                    // Restore connections
                    workflow.connections.forEach(conn => {
                        const fromId = idMap[conn.from.nodeId];
                        const toId = idMap[conn.to.nodeId];
                        if (fromId && toId) {
                            createConnection(fromId, conn.from.port, toId, conn.to.port);
                        }
                    });
                    
                    updateStatus();
                    updatePortStyles();
                    
                    // Visual feedback
                    const btn = document.getElementById('importBtn');
                    const originalText = btn.textContent;
                    btn.textContent = '✅ Loaded';
                    btn.style.background = '#22c55e';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 1000);
                    
                } catch (err) {
                    alert(`❌ Failed to load: ${err.message}`);
                }
            }
        });

        // Try to restore autosave on page load
        window.addEventListener('DOMContentLoaded', () => {
            const autosaved = localStorage.getItem('workflow_autosave');
            if (autosaved && state.nodes.length === 0) {
                try {
                    const workflow = JSON.parse(autosaved);
                    if (workflow.nodes && workflow.nodes.length > 0) {
                        console.log('💡 Found autosaved workflow. Press Ctrl+O to restore it.');
                    }
                } catch (err) {
                    console.warn('Could not parse autosave:', err);
                }
            }
        });

        // Initialize with sample workflow
        setTimeout(() => {
            createNode('symbol', 100, 50);
            createNode('timeframe', 100, 180);
            createNode('lookback', 100, 310);
            createNode('input', 400, 150);
            createNode('rsi', 700, 130);
            createNode('signal', 1000, 150);
        }, 100);

        // ========== PREMIUM RESULTS PANEL SYSTEM ==========
        
        // Signal history store
        window.signalHistory = [];
        const MAX_SIGNALS = 10;

        // Toggle results panel
        function toggleResultsPanel() {
            const panel = document.getElementById('resultsPanel');
            const wasOpen = panel.classList.contains('open');
            panel.classList.toggle('open');
            
            // Clear node execution colors when closing panel
            if (wasOpen && typeof clearWorkflowNodeColors === 'function') {
                clearWorkflowNodeColors();
            }
        }

        // Update AI Strategy Analysis with actual AI agent output
        function updateAIAnalysisWithAgentOutput(workflowData, latestPrice, aiAgentBlocks) {
            const analysisBox = document.getElementById('aiAnalysisBox');
            const { blocks, success, final_decision } = workflowData;
            
            // Build HTML showing AI agent results
            let html = `
                <div class="ai-analysis-label">
                    <div class="ai-status-dot"></div>
                    AI Agent Analysis · ${new Date().toLocaleTimeString()}
                </div>
            `;
            
            aiAgentBlocks.forEach((aiBlock, idx) => {
                const agentData = aiBlock.data || {};
                const analysis = agentData.analysis || 'No analysis provided';
                const model = agentData.model || aiBlock.params?.model || 'unknown';
                const provider = agentData.provider || aiBlock.params?.provider || 'unknown';
                const action = agentData.action || 'neutral';
                const error = agentData.error;
                
                let actionColor = '#9ca3af';
                let actionIcon = '⚪';
                if (action === 'bullish') {
                    actionColor = '#22c55e';
                    actionIcon = '🟢';
                } else if (action === 'bearish') {
                    actionColor = '#ef4444';
                    actionIcon = '🔴';
                }
                
                html += `
                    <div style="margin-top: 12px; padding: 14px; background: linear-gradient(135deg, rgba(41,98,255,0.08) 0%, rgba(41,98,255,0.02) 100%); border-left: 4px solid ${actionColor}; border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div style="font-size: 11px; font-weight: 600; color: #9ca3af; text-transform: uppercase; letter-spacing: 0.5px;">
                                ${actionIcon} ${provider} · ${model}
                            </div>
                            <div style="font-size: 10px; color: ${actionColor}; font-weight: 700;">
                                ${action.toUpperCase()}
                            </div>
                        </div>
                        ${error ? `
                            <div style="padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 6px; margin-bottom: 10px;">
                                <div style="font-size: 11px; color: #ef4444; font-weight: 600;">⚠️ Error</div>
                                <div style="font-size: 12px; color: #fca5a5; margin-top: 4px;">${error}</div>
                            </div>
                        ` : ''}
                        <div class="ai-analysis-text">
                            ${analysis}
                        </div>
                    </div>
                `;
            });
            
            // Add condition status section
            html += `
                <div style="margin-top: 16px; padding: 14px; background: rgba(30, 34, 45, 0.6); border-radius: 8px; border: 1px solid #2a2e39;">
                    <div style="font-size: 11px; font-weight: 600; color: #60a5fa; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;">
                        📊 Condition Status
                    </div>
            `;
            
            blocks.forEach((block, idx) => {
                const statusColor = block.status === 'passed' ? '#22c55e' : block.status === 'failed' ? '#ef4444' : '#9ca3af';
                const statusIcon = block.status === 'passed' ? '✓' : block.status === 'failed' ? '✗' : '⊘';
                const blockName = block.block_type.toUpperCase().replace(/_/g, ' ');
                
                html += `
                    <div style="display: flex; align-items: flex-start; gap: 10px; margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                        <div style="font-size: 14px; color: ${statusColor}; min-width: 20px;">${statusIcon}</div>
                        <div style="flex: 1;">
                            <div style="font-size: 12px; font-weight: 600; color: #e5e7eb;">${blockName}</div>
                            <div style="font-size: 11px; color: ${statusColor}; margin-top: 2px;">${block.message || 'No details'}</div>
                        </div>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            html += `
                <div class="ai-status-bar">
                    <div class="ai-status-item">
                        <div class="ai-status-dot"></div>
                        Live
                    </div>
                    <div class="ai-status-item">
                        Price: $${latestPrice.toFixed(2)}
                    </div>
                    <div class="ai-status-item">
                        Decision: ${final_decision}
                    </div>
                </div>
            `;
            
            analysisBox.innerHTML = html;
        }

        // Update AI Strategy Analysis
        function updateAIAnalysis(workflowData, latestPrice) {
            const analysisBox = document.getElementById('aiAnalysisBox');
            const { blocks, success, final_decision, latest_data } = workflowData;
            
            // Analyze workflow structure
            const blockTypes = blocks.map(b => b.block_type);
            const indicators = blockTypes.filter(t => ['rsi', 'ema', 'macd', 'bollinger', 'vwap', 'stochastic'].includes(t));
            const logicGates = blockTypes.filter(t => ['and', 'or', 'not'].includes(t));
            const hasAI = blockTypes.includes('ai_agent');
            
            // Determine strategy type
            let strategyType = 'Mixed Strategy';
            if (indicators.includes('rsi') && indicators.includes('macd')) {
                strategyType = 'Momentum-Based Strategy';
            } else if (indicators.includes('ema') || indicators.includes('bollinger')) {
                strategyType = 'Trend-Following Strategy';
            } else if (indicators.includes('volspike') || indicators.includes('obv')) {
                strategyType = 'Volume-Driven Strategy';
            }
            
            // Analyze recent triggers
            const passedBlocks = blocks.filter(b => b.status === 'passed');
            const failedBlocks = blocks.filter(b => b.status === 'failed');
            
            // Check which conditions are close to triggering
            let closeToTrigger = [];
            blocks.forEach(block => {
                if (block.block_type === 'rsi' && latest_data.rsi) {
                    const rsi = latest_data.rsi;
                    const rsiNode = state.nodes.find(n => n.type === 'rsi');
                    const oversoldCfg = parseFloat(rsiNode?.configValues?.oversold ?? 30);
                    const overboughtCfg = parseFloat(rsiNode?.configValues?.overbought ?? 70);
                    const low = Math.min(oversoldCfg, overboughtCfg);
                    const high = Math.max(oversoldCfg, overboughtCfg);
                    const nearBandPct = 0.07; // within 7% of threshold range size
                    const span = Math.max(1, high - low);
                    const nearHighLowerBound = high - span * nearBandPct;
                    const nearLowUpperBound = low + span * nearBandPct;
                    if (rsi >= nearHighLowerBound && rsi < high) closeToTrigger.push(`RSI approaching overbought (${high})`);
                    if (rsi <= nearLowUpperBound && rsi > low) closeToTrigger.push(`RSI approaching oversold (${low})`);
                }
                if (block.block_type === 'macd' && latest_data.macd_hist !== undefined) {
                    const hist = latest_data.macd_hist;
                    if (Math.abs(hist) < 0.5) closeToTrigger.push('MACD histogram near zero crossing');
                }
            });
            
            // Generate analysis text
            let html = `
                <div class="ai-analysis-label">
                    <div class="ai-status-dot"></div>
                    Live Analysis · ${new Date().toLocaleTimeString()}
                </div>
                <div class="ai-analysis-text">
                    <strong>Strategy Type:</strong> <span class="ai-analysis-highlight">${strategyType}</span>
                    <br><br>
                    Your workflow uses <strong>${indicators.length} technical indicator${indicators.length !== 1 ? 's' : ''}</strong> 
                    ${logicGates.length > 0 ? `combined with ${logicGates.length} logic gate${logicGates.length !== 1 ? 's' : ''}` : ''}
                    ${hasAI ? ' and enhanced with AI analysis' : ''}.
                </div>
            `;
            
            if (passedBlocks.length > 0) {
                const triggerNames = passedBlocks.map(b => b.block_type.toUpperCase()).join(', ');
                html += `
                    <div class="ai-analysis-text">
                        <strong>Recently Triggered:</strong> ${triggerNames}
                        <br>
                        ${passedBlocks.length === blocks.length ? 
                            '<span style="color: #22c55e;">✓ All conditions met - strategy confirmed</span>' : 
                            `${passedBlocks.length}/${blocks.length} conditions passed`
                        }
                    </div>
                `;
            }
            
            if (closeToTrigger.length > 0) {
                html += `
                    <div class="ai-analysis-text">
                        <strong>Close to Triggering:</strong>
                        <br>• ${closeToTrigger.join('<br>• ')}
                    </div>
                `;
            }
            
            if (failedBlocks.length > 0 && !success) {
                const firstFail = failedBlocks[0];
                html += `
                    <div class="ai-analysis-text">
                        <strong>Why Strategy Stopped:</strong>
                        <br>${firstFail.block_type.toUpperCase()} condition not met - ${firstFail.message || 'criteria not satisfied'}
                    </div>
                `;
            }
            
            // Strategy weaknesses
            html += `
                <div class="ai-analysis-text">
                    <strong>Key Observations:</strong>
                    <br>• ${logicGates.length === 0 ? 
                        'Consider adding logic gates (AND/OR) for more precise entry conditions' : 
                        'Logic gates provide good condition filtering'}
                    <br>• ${indicators.length < 2 ? 
                        'Single-indicator strategies may generate false signals' : 
                        'Multiple indicators provide confirmation'}
                    <br>• ${hasAI ? 
                        'AI agent adds contextual market analysis' : 
                        'Consider adding an AI Agent for deeper market insights'}
                </div>
            `;
            
            // Add condition status section ABOVE the analysis
            html = `
                <div style="margin-bottom: 16px; padding: 14px; background: rgba(30, 34, 45, 0.6); border-radius: 8px; border: 1px solid #2a2e39;">
                    <div style="font-size: 11px; font-weight: 600; color: #60a5fa; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px;">
                        📊 Condition Status
                    </div>
            ` + blocks.map(block => {
                const statusColor = block.status === 'passed' ? '#22c55e' : block.status === 'failed' ? '#ef4444' : '#9ca3af';
                const statusIcon = block.status === 'passed' ? '✓' : block.status === 'failed' ? '✗' : '⊘';
                const blockName = block.block_type.toUpperCase().replace(/_/g, ' ');
                return `
                    <div style="display: flex; align-items: flex-start; gap: 10px; margin-bottom: 8px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px;">
                        <div style="font-size: 14px; color: ${statusColor}; min-width: 20px;">${statusIcon}</div>
                        <div style="flex: 1;">
                            <div style="font-size: 12px; font-weight: 600; color: #e5e7eb;">${blockName}</div>
                            <div style="font-size: 11px; color: ${statusColor}; margin-top: 2px;">${block.message || 'No details'}</div>
                        </div>
                    </div>
                `;
            }).join('') + `</div>` + html;
            
            html += `
                <div class="ai-status-bar">
                    <div class="ai-status-item">
                        <div class="ai-status-dot"></div>
                        Live
                    </div>
                    <div class="ai-status-item">
                        Price: $${latestPrice.toFixed(2)}
                    </div>
                    <div class="ai-status-item">
                        ${blocks.length} blocks
                    </div>
                </div>
            `;
            
            analysisBox.innerHTML = html;
        }

        // Fetch Gemini analysis (disabled - AI agent provides analysis)
        async function fetchGeminiAnalysis({ symbol, timeframe, strategyData, workflowData }) {
            // Gemini perspective removed - AI agent block now provides all analysis
            console.log('Gemini analysis skipped - using AI agent output instead');
            return;
        }

        // Manual refresh wrapper
        function refreshGemini() {
            if (!window.lastPanelData) {
                console.warn('No last workflow data to refresh Gemini analysis.');
                return;
            }
            const { summary, latest_data } = window.lastPanelData;
            const symbol = summary?.symbol || 'SPY';
            const timeframe = summary?.timeframe || '1Hour';
            fetchGeminiAnalysis({ symbol, timeframe, strategyData: window.lastPanelData, workflowData: window.lastPanelData });
        }

        // Streaming partial updates from runner
        window.partialAnalysisUpdate = function({ processed, total, lastStatus, lastType, halted }) {
            const box = document.getElementById('aiAnalysisBox');
            if (!box) return;
            let progressEl = document.getElementById('aiProgressLine');
            const pct = Math.min(100, Math.round((processed / total) * 100));
            if (!progressEl) {
                progressEl = document.createElement('div');
                progressEl.id = 'aiProgressLine';
                progressEl.style.marginTop = '12px';
                progressEl.style.fontSize = '11px';
                progressEl.style.color = '#9ca3af';
                box.appendChild(progressEl);
            }
            progressEl.innerHTML = `
                <div style="display:flex; align-items:center; gap:8px;">
                    <div style="flex:1; background:#131722; border:1px solid #2a2e39; height:6px; border-radius:4px; overflow:hidden;">
                        <div style="height:100%; width:${pct}%; background:linear-gradient(90deg,#2962ff,#5e8cff);"></div>
                    </div>
                    <span style="color:#60a5fa; font-weight:600;">${pct}%</span>
                </div>
                <div style="margin-top:6px; line-height:1.4;">
                    Block ${processed}/${total} • Last: <strong style="color:${lastStatus==='passed' ? '#22c55e' : lastStatus==='failed' ? '#ef4444' : '#9ca3af'};">${lastType}</strong> (${lastStatus})${halted ? ' • Execution halted' : ''}
                </div>
            `;
        };

        // Add signal to history
        function addSignalToHistory(signal) {
            try { console.log('addSignalToHistory called with', signal); } catch(_){ }
            // Normalize price to a finite number sourced from BUY/SELL @ price context
            const rawPrice = signal && signal.price;
            const normalizedPrice = typeof rawPrice === 'number' ? rawPrice : parseFloat(rawPrice);
            signal.price = Number.isFinite(normalizedPrice) ? normalizedPrice : 0;
            // Preserve only required fields
            const cleaned = {
                timestamp: signal.timestamp || new Date().toISOString(),
                type: signal.type || 'CONFIRMED',
                label: signal.label || (signal.type === 'BUY' ? 'Confirmed Bullish Signal' : signal.type === 'SELL' ? 'Confirmed Bearish Signal' : 'Confirmed Signal'),
                price: signal.price,
                trigger: signal.trigger || 'Final Block'
            };
            window.signalHistory.unshift(cleaned);
            if (window.signalHistory.length > MAX_SIGNALS) {
                window.signalHistory = window.signalHistory.slice(0, MAX_SIGNALS);
            }
            updateSignalList();
        }

        // Update signal list display
        function updateSignalList() {
            const signalList = document.getElementById('signalList');
            
            if (window.signalHistory.length === 0) {
                signalList.innerHTML = `
                    <div class="signal-empty">
                        <div class="signal-empty-icon">📈</div>
                        <div class="signal-empty-text">
                            No signals recorded yet.<br>
                            Execute your workflow to track signals here.
                        </div>
                    </div>
                `;
                // Clear chart in bottom drawer
                const canvas = document.getElementById('signalHistoryChart');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                return;
            }
            
            signalList.innerHTML = window.signalHistory.map(signal => {
                const iconMap = {
                    'BUY': { class: 'buy', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 2L12 22" stroke="#16a34a" stroke-width="2" stroke-linecap="round"/><path d="M5 9l7-7 7 7" stroke="#16a34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>', action: 'BUY' },
                    'SELL': { class: 'sell', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 22L12 2" stroke="#ef4444" stroke-width="2" stroke-linecap="round"/><path d="M19 15l-7 7-7-7" stroke="#ef4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>', action: 'SELL' },
                    'CONFIRMED': { class: 'buy', icon: '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20 6L9 17l-5-5" stroke="#10b981" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>', action: 'CONFIRMED' },
                    'NEUTRAL': { class: 'neutral', icon: '<svg width="12" height="12" viewBox="0 0 24 24" fill="#9ca3af" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="6" /></svg>', action: 'HOLD' },
                    'HOLD': { class: 'neutral', icon: '<svg width="12" height="12" viewBox="0 0 24 24" fill="#9ca3af" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="10" width="12" height="4" rx="1"/></svg>', action: 'HOLD' }
                };
                const { class: className, icon, action } = iconMap[signal.type] || iconMap['NEUTRAL'];
                const displayLabel = signal.label || signal.type;
                const time = new Date(signal.timestamp);
                const timeStr = time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const dateStr = time.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const currentSymbol = (typeof safeGetCurrentSymbol === 'function' ? safeGetCurrentSymbol() : (typeof getCurrentSymbol === 'function' ? getCurrentSymbol() : (typeof window.getCurrentSymbol === 'function' ? window.getCurrentSymbol() : null))) || 'N/A';
                
                return `
                    <div class="signal-item" onclick="highlightSignalOnChart('${signal.timestamp}')">
                        <div class="signal-item-header">
                            <div class="signal-type">
                                <div class="signal-icon ${className}">${icon}</div>
                                <div style="display:flex; flex-direction:column; gap:2px;">
                                    <span class="signal-type-text">${displayLabel}</span>
                                    <span style="font-size:11px; color:#9ca3af;">${currentSymbol} ${action} @ $${signal.price.toFixed(2)}</span>
                                </div>
                            </div>
                            <div style="display:flex; flex-direction:column; align-items:flex-end; gap:2px;">
                                <div class="signal-timestamp">${timeStr}</div>
                                <div style="font-size:10px; color:#6b7280;">${dateStr}</div>
                            </div>
                        </div>
                        <div class="signal-item-body" style="margin-top:8px;">
                            <div class="signal-trigger" style="font-size:11px;">Trigger: ${signal.trigger}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Draw signal history chart in bottom drawer
            drawSignalHistoryChart();
        }
        
        // Premium Stock Price Chart - Auto-connects to Alpaca node settings
        let chartTransitionOpacity = 1;
        let isChartTransitioning = false;
        
        function drawSignalHistoryChart() {
            const canvas = document.getElementById('signalHistoryChart');
            const placeholder = document.getElementById('chartPlaceholder');
            if (!canvas) return;
            
            // Check if we have price data
            if (!window.priceHistoryBars || window.priceHistoryBars.length === 0) {
                canvas.style.opacity = '0';
                if (placeholder) placeholder.style.display = 'block';
                return;
            }
            
            // Hide placeholder, show chart
            if (placeholder) placeholder.style.display = 'none';
            canvas.style.opacity = chartTransitionOpacity;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 2;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            
            const width = rect.width;
            const height = rect.height;
            const padding = {left: 10, right: 60, top: 20, bottom: 35};
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;
            
            // Clear with fade effect
            ctx.clearRect(0, 0, width, height);
            ctx.globalAlpha = chartTransitionOpacity;
            
            const bars = window.priceHistoryBars;
            const closes = bars.map(b => b.close);
            const minPrice = Math.min(...closes);
            const maxPrice = Math.max(...closes);
            const priceRange = maxPrice - minPrice || 1;
            const buffer = priceRange * 0.05; // 5% buffer
            
            // Draw subtle grid
            ctx.strokeStyle = 'rgba(31, 41, 55, 0.5)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }
            
            // Price labels (right side)
            ctx.fillStyle = '#9ca3af';
            ctx.font = '10px monospace';
            ctx.textAlign = 'left';
            for (let i = 0; i <= 4; i++) {
                const price = maxPrice - (priceRange / 4) * i;
                const y = padding.top + (chartHeight / 4) * i;
                ctx.fillText(`$${price.toFixed(2)}`, width - padding.right + 8, y + 4);
            }
            
            // Convert price to Y coordinate
            const priceToY = (price) => {
                const normalized = (price - (minPrice - buffer)) / (priceRange + buffer * 2);
                return padding.top + chartHeight - (normalized * chartHeight);
            };
            
            // Store line points for hover detection
            window.chartLinePoints = [];
            
            // Draw premium line chart with gradient
            const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
            gradient.addColorStop(0, 'rgba(96, 165, 250, 0.8)');
            gradient.addColorStop(1, 'rgba(96, 165, 250, 0.2)');
            
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 2.5;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(96, 165, 250, 0.5)';
            ctx.shadowBlur = 4;
            
            ctx.beginPath();
            bars.forEach((bar, i) => {
                const x = padding.left + (chartWidth / (bars.length - 1 || 1)) * i;
                const y = priceToY(bar.close);
                window.chartLinePoints.push({ x, y, price: bar.close, time: bar.t });
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Area fill with gradient
            ctx.lineTo(padding.left + chartWidth, height - padding.bottom);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Time labels (X-axis)
            ctx.fillStyle = '#6b7280';
            ctx.font = '9px monospace';
            ctx.textAlign = 'center';
            
            const labelCount = Math.min(6, bars.length);
            for (let i = 0; i < labelCount; i++) {
                const idx = Math.floor((i / (labelCount - 1 || 1)) * (bars.length - 1));
                const bar = bars[idx];
                if (bar && bar.t) {
                    const x = padding.left + (chartWidth / (bars.length - 1 || 1)) * idx;
                    const time = new Date(bar.t);
                    const formatted = time.toLocaleTimeString('en-US', { 
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    ctx.fillText(formatted, x, height - padding.bottom + 20);
                }
            }
            
            // Update price info with smooth color transition
            if (bars.length > 0) {
                const latest = bars[bars.length - 1];
                const first = bars[0];
                const change = latest.close - first.open;
                const changePct = ((change / first.open) * 100).toFixed(2);
                const infoEl = document.getElementById('stockPriceInfo');
                if (infoEl) {
                    const arrow = change >= 0 ? '▲' : '▼';
                    const color = change >= 0 ? '#26a69a' : '#ef5350';
                    const symbol = getCurrentSymbol();
                    infoEl.innerHTML = `<span style="color:#e5e7eb;">${symbol}</span> $${latest.close.toFixed(2)} <span style="color:${color};">${arrow} ${changePct}%</span>`;
                }
            }
            
            ctx.globalAlpha = 1;
        }

        // =============================================================
        // Strategy Insights Price Chart (Closing Prices Only)
        // =============================================================
        let insightsChartTransition = 1;
        let insightsChartAnimating = false;

        function renderInsightsPriceChart() {
            const canvas = document.getElementById('insightsPriceChart');
            const placeholderEl = document.getElementById('priceChartPlaceholder');
            const errorEl = document.getElementById('priceChartError');
            const headerEl = document.getElementById('priceChartHeader');
            if (!canvas || !headerEl) return;

            const symbol = getCurrentSymbol();
            const tf = window.selectedTimeframe || '1m';
            const displayTf = tf.toLowerCase();
            // Do not render any header text per design
            headerEl.textContent = '';

            // State checks
            if (!symbol) {
                if (placeholderEl) { placeholderEl.style.display = 'flex'; placeholderEl.textContent = 'Select a symbol to view price history.'; }
                if (errorEl) errorEl.style.display = 'none';
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,canvas.width,canvas.height);
                return;
            }
            if (!window.priceHistoryBars || window.priceHistoryBars.length === 0) {
                if (window._lastPriceFetchError) {
                    if (errorEl) { errorEl.style.display = 'flex'; errorEl.textContent = 'Unable to load price data.'; }
                    if (placeholderEl) placeholderEl.style.display = 'none';
                } else {
                    if (placeholderEl) { placeholderEl.style.display = 'flex'; placeholderEl.textContent = 'Loading price data...'; }
                    if (errorEl) errorEl.style.display = 'none';
                }
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0,0,canvas.width,canvas.height);
                return;
            }

            // Hide placeholders
            if (placeholderEl) placeholderEl.style.display = 'none';
            if (errorEl) errorEl.style.display = 'none';

            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 2;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;
            const padding = { left: 12, right: 58, top: 18, bottom: 30 };
            const chartW = width - padding.left - padding.right;
            const chartH = height - padding.top - padding.bottom;
            ctx.clearRect(0,0,width,height);
            ctx.globalAlpha = insightsChartTransition;

            const bars = window.priceHistoryBars;
            const closes = bars.map(b => b.close);
            const min = Math.min(...closes);
            const max = Math.max(...closes);
            const range = (max - min) || 1;
            const buffer = range * 0.04; // 4% visual buffer

            // Gridlines (horizontal + subtle vertical)
            ctx.strokeStyle = 'rgba(31,41,55,0.4)';
            ctx.lineWidth = 1;
            for (let i=0;i<=4;i++) {
                const y = padding.top + (chartH/4)*i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();
            }
            const vSteps = Math.min(8, bars.length);
            ctx.strokeStyle = 'rgba(31,41,55,0.25)';
            for (let i=0;i<vSteps;i++) {
                const x = padding.left + (chartW/(vSteps-1||1))*i;
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, height - padding.bottom);
                ctx.stroke();
            }

            // Price scale (right)
            ctx.fillStyle = '#9ca3af';
            ctx.font = '10px monospace';
            for (let i=0;i<=4;i++) {
                const p = max - (range/4)*i;
                const y = padding.top + (chartH/4)*i;
                ctx.fillText(`$${p.toFixed(2)}`, width - padding.right + 6, y + 4);
            }

            const priceToY = (p) => {
                const normalized = (p - (min - buffer)) / (range + buffer*2);
                return padding.top + chartH - (normalized * chartH);
            };

            // Line + gradient area
            const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
            gradient.addColorStop(0,'rgba(59,130,246,0.9)');
            gradient.addColorStop(1,'rgba(59,130,246,0.18)');

            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2.2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(59,130,246,0.4)';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            window._insightsPricePoints = [];
            bars.forEach((bar,i)=>{
                const x = padding.left + (chartW/(bars.length-1||1))*i;
                const y = priceToY(bar.close);
                window._insightsPricePoints.push({x,y,price:bar.close,time:bar.t});
                if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            });
            ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.lineTo(padding.left + chartW, height - padding.bottom);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Time scale (bottom)
            ctx.fillStyle = '#6b7280';
            ctx.font = '9px monospace';
            ctx.textAlign = 'center';
            const labelCount = Math.min(6, bars.length);
            for (let i=0;i<labelCount;i++) {
                const idx = Math.floor((i/(labelCount-1||1))*(bars.length-1));
                const bar = bars[idx];
                const x = padding.left + (chartW/(bars.length-1||1))*idx;
                const dt = new Date(bar.t);
                const label = dt.toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'});
                ctx.fillText(label, x, height - padding.bottom + 18);
            }

            // Latest price change summary (optional subtle watermark)
            try {
                const first = bars[0];
                const last = bars[bars.length-1];
                const change = last.close - first.close;
                const pct = (change/first.close*100).toFixed(2);
                ctx.fillStyle = change >=0 ? '#10b981' : '#ef4444';
                ctx.font = '11px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(`${last.close.toFixed(2)} (${change>=0?'+':''}${pct}%)`, width - padding.right - 4, padding.top + 12);
            } catch(e) {}

            ctx.globalAlpha = 1;
        }

            // =============================================================
            // Live Pulls Chart (time on X, stock price on Y)
            // =============================================================
        window.renderPullsChart = function() {
            const canvas = document.getElementById('drawerPullsChart') || document.getElementById('pullsChart');
            const empty = document.getElementById('pullsChartEmpty');
            if (!canvas) return;

            const history = (window.monitor && Array.isArray(window.monitor.history)) ? window.monitor.history : [];
            // Determine lookback days from alpaca config
            let days = 7;
            try {
                if (window.state && Array.isArray(window.state.nodes)) {
                    const node = window.state.nodes.find(n => n.type === 'alpaca_config');
                    if (node && node.configValues && node.configValues.days) days = parseInt(node.configValues.days) || days;
                }
            } catch(_){}
            const cutoff = Date.now() - (days * 24 * 3600 * 1000);
            // Normalize history entries and keep only valid price points
            let points = history
                .map(h => ({...h, t: new Date(h.ts).getTime()}))
                .filter(h => typeof h.latestPrice === 'number' && !isNaN(h.latestPrice))
                .sort((a,b) => (a.t||0) - (b.t||0));
            // Show only the most recent 3600 pulls to avoid overly dense plots
            if (points.length > 3600) points = points.slice(-3600);

            // Responsive chart sizing with debounce
            let rect = canvas.getBoundingClientRect();
            let dpr = window.devicePixelRatio || 1;
            let widthCss = rect.width || canvas.clientWidth || 600;
            let heightCss = rect.height || 220;
            // Maintain aspect ratio for candles
            if (widthCss < 400) heightCss = Math.max(160, widthCss * 0.6);
            else if (widthCss > 900) heightCss = Math.min(340, widthCss * 0.38);
            canvas.width = Math.max(1, Math.floor(widthCss * dpr));
            canvas.height = Math.max(1, Math.floor(heightCss * dpr));
            const ctx = canvas.getContext('2d');
            ctx.setTransform(dpr,0,0,dpr,0,0);
            // Professional dark background
            ctx.fillStyle = '#181A20';
            ctx.fillRect(0,0,widthCss,heightCss);

            if (points.length === 0) {
                if (empty) empty.style.display = 'flex';
                // Clear canvas for drawer chart so it doesn't show stale data
                const rect0 = canvas.getBoundingClientRect();
                const dpr0 = window.devicePixelRatio || 1;
                const w0 = rect0.width || canvas.clientWidth || 600;
                const h0 = rect0.height || 180;
                canvas.width = Math.max(1, Math.floor(w0 * dpr0));
                canvas.height = Math.max(1, Math.floor(h0 * dpr0));
                const ctx0 = canvas.getContext('2d');
                ctx0.setTransform(dpr0,0,0,dpr0,0,0);
                ctx0.clearRect(0,0,w0,h0);
                return;
            }
            if (empty) empty.style.display = 'none';

            // Compute scales
            const padding = { left: Math.max(56, widthCss*0.07), right: Math.max(20, widthCss*0.04), top: 24, bottom: 36 };
            const plotW = widthCss - padding.left - padding.right;
            const plotH = heightCss - padding.top - padding.bottom;
            const tMin = Math.min(...points.map(p => p.t));
            const tMax = Math.max(...points.map(p => p.t));
            // Dynamic price scaling with padding
            const yMinRaw = Math.min(...points.map(p => p.latestPrice));
            const yMaxRaw = Math.max(...points.map(p => p.latestPrice));
            const yPad = (yMaxRaw-yMinRaw)*0.08 || 1;
            const yMin = yMinRaw - yPad;
            const yMax = yMaxRaw + yPad;
            const tSpan = Math.max(1, tMax - tMin);
            const ySpan = Math.max(1e-6, yMax - yMin);
            const xOf = v => padding.left + ((v - tMin) / tSpan) * plotW;
            const yOf = v => padding.top + (1 - (v - yMin) / ySpan) * plotH;

            // Subtle grid lines with dynamic density (lighter for dark theme)
            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,0.04)';
            ctx.lineWidth = 1;
            // Dynamic Y grid density
            let yTicks = 5;
            if (plotH < 120) yTicks = 3;
            else if (plotH > 320) yTicks = 7;
            for (let i=0;i<=yTicks;i++){
                const y = padding.top + (i/yTicks)*plotH;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + plotW, y);
                ctx.stroke();
            }
            // Dynamic X grid density
            let xTicks = Math.min(8, Math.max(2, Math.floor(plotW/110)));
            if (plotW < 300) xTicks = Math.max(2, Math.floor(plotW/160));
            for (let i=0;i<=xTicks;i++){
                const x = padding.left + (i/xTicks)*plotW;
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, padding.top + plotH);
                ctx.stroke();
            }
            ctx.restore();

            // Axes lines
            ctx.strokeStyle = '#2a2e39';
            ctx.lineWidth = 1.25;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, padding.top + plotH);
            ctx.lineTo(padding.left + plotW, padding.top + plotH);
            ctx.stroke();

            // Y-axis labels (price)
            ctx.fillStyle = '#A1A6B2';
            ctx.font = '12px Inter, monospace';
            ctx.textAlign = 'right';
            for (let i=0;i<=yTicks;i++){
                const val = yMin + (1-i/yTicks)*(yMax-yMin);
                const y = padding.top + (i/yTicks)*plotH;
                ctx.fillText('$'+val.toFixed(2), padding.left - 8, y + 4);
            }

            // X-axis labels (auto-format)
            ctx.font = '11px Inter, monospace';
            ctx.fillStyle = '#A1A6B2';
            ctx.textAlign = 'center';
            let lastLabelX = -Infinity;
            for (let i=0;i<=xTicks;i++){
                const t = tMin + (i/xTicks)*(tMax-tMin);
                const x = padding.left + (i/xTicks)*plotW;
                let label;
                if ((tMax-tMin)<1000*60*60*6) label = new Date(t).toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'});
                else label = new Date(t).toLocaleString('en-US',{month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'});
                if (x-lastLabelX > 40) { ctx.fillText(label, x, padding.top+plotH+18); lastLabelX = x; }
            }

            // Axis titles
            ctx.save();
            ctx.fillStyle = '#9ca3af';
            ctx.font = '12px Inter, monospace';
            ctx.textAlign = 'center';
            // X title
            ctx.fillText('Time', padding.left + plotW/2, padding.top + plotH + 32);
            // Y title rotated
            ctx.translate(14, padding.top + plotH/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Stock Price ($)', 0, 0);
            ctx.restore();

            // Price line (high-contrast) with smooth join, shadow and subtle area fill
            ctx.save();
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#3B82F6';
            ctx.lineWidth = Math.max(2,Math.floor(widthCss/220));
            ctx.shadowColor = 'rgba(59,130,246,0.12)';
            ctx.shadowBlur = 8;
            // Draw stroke path
            ctx.beginPath();
            points.forEach((p, i) => {
                const x = xOf(p.t), y = yOf(p.latestPrice);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();
            ctx.shadowBlur = 0;
            // Area gradient under line
            const grad = ctx.createLinearGradient(0, padding.top, 0, padding.top + plotH);
            grad.addColorStop(0, 'rgba(59,130,246,0.12)');
            grad.addColorStop(1, 'rgba(59,130,246,0.02)');
            ctx.fillStyle = grad;
            // Fill area under curve (destination-over so fill sits beneath stroke)
            ctx.globalCompositeOperation = 'destination-over';
            ctx.beginPath();
            points.forEach((p, i) => {
                const x = xOf(p.t), y = yOf(p.latestPrice);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            // Close path to bottom
            ctx.lineTo(padding.left + plotW, padding.top + plotH);
            ctx.lineTo(padding.left, padding.top + plotH);
            ctx.closePath();
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();

            // Signal markers (BUY/SELL/HOLD)
            // Responsive marker sizing
            const markerBase = Math.max(8, Math.floor(Math.min(plotW, plotH) / 22));
            const markerLabelFont = Math.max(10, Math.floor(markerBase * 0.9));
            points.forEach(p => {
                const x = xOf(p.t), y = yOf(p.latestPrice);
                // Find matching signal in signalHistory by timestamp
                const signal = window.signalHistory && window.signalHistory.find(s => {
                    // Use same timestamp format as points
                    return Math.abs(new Date(s.timestamp).getTime() - p.t) < 60000 && (s.type === 'BUY' || s.type === 'SELL');
                });
                if (signal && signal.type === 'BUY') {
                    // Upward green triangle below price
                    ctx.save();
                    ctx.fillStyle = '#22c55e';
                    ctx.beginPath();
                    ctx.moveTo(x, y + markerBase * 1.5);
                    ctx.lineTo(x - markerBase, y + markerBase * 0.2);
                    ctx.lineTo(x + markerBase, y + markerBase * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // BUY label
                    ctx.font = `${markerLabelFont}px monospace`;
                    ctx.fillStyle = '#22c55e';
                    ctx.textAlign = 'center';
                    ctx.fillText('BUY', x, y + markerBase * 2.3);
                    ctx.restore();
                } else if (signal && signal.type === 'SELL') {
                    // Downward red triangle above price
                    ctx.save();
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath();
                    ctx.moveTo(x, y - markerBase * 1.5);
                    ctx.lineTo(x - markerBase, y - markerBase * 0.2);
                    ctx.lineTo(x + markerBase, y - markerBase * 0.2);
                    ctx.closePath();
                    ctx.fill();
                    // SELL label
                    ctx.font = `${markerLabelFont}px monospace`;
                    ctx.fillStyle = '#ef4444';
                    ctx.textAlign = 'center';
                    ctx.fillText('SELL', x, y - markerBase * 2.0);
                    ctx.restore();
                } else {
                    // Only show neutral gray dot if no signal
                    ctx.save();
                    ctx.fillStyle = '#A1A6B2';
                    ctx.beginPath();
                    ctx.arc(x, y, Math.max(3, Math.floor(markerBase * 0.5)), 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            });

            // Labels: last price and timeframe
            try {
                const last = points[points.length - 1];
                const tf = (window.selectedTimeframe || (window.vars && window.vars.get('timeframe')) || '').toUpperCase();
                ctx.fillStyle = '#A1A6B2';
                ctx.font = '11px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Last $${(last.latestPrice||0).toFixed(2)} ${tf ? '· '+tf : ''}`, padding.left + 4, padding.top - 6 + 11);
            } catch(_){}

            // Store points for hover/cursor use
            window._pullsPoints = points.map(p => ({ time: p.t, price: p.latestPrice, x: xOf(p.t), y: yOf(p.latestPrice) }));
            window._pullsCanvas = canvas;
            window._pullsPlot = { padding, width: widthCss, height: heightCss };
        };

        // Resize observer for live pulls chart (drawer and/or insights)
        // Responsive resize observer with debounce
        (function(){
            const targets = [
                document.getElementById('drawerPullsChart'),
                document.getElementById('pullsChart')
            ].filter(Boolean);
            if (targets.length === 0) return;
            let resizeTimeout = null;
            const ro = new ResizeObserver(() => {
                if (resizeTimeout) clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    window.renderPullsChart && window.renderPullsChart();
                }, 120);
            });
            targets.forEach(t => ro.observe(t));
        })();

        // Hover interactions for drawer live pulls chart
        ;(function initDrawerPullsHover(){
            const canvas = document.getElementById('drawerPullsChart');
            if (!canvas) return;
            const tooltip = document.getElementById('drawerTooltip');
            const ttTime = document.getElementById('tooltipTime');
            const ttPrice = document.getElementById('tooltipPrice');
            const cursor = document.getElementById('drawerCursor');
            if (!tooltip || !ttTime || !ttPrice) return;

            canvas.addEventListener('mousemove', (e) => {
                if (!window._pullsPoints || window._pullsPoints.length === 0 || window._pullsCanvas !== canvas) return;
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                let nearest = null; let min = Infinity;
                for (const pt of window._pullsPoints) {
                    const d = Math.abs(pt.x - mx);
                    if (d < min) { min = d; nearest = pt; }
                }
                if (nearest && min < 30) {
                    ttTime.textContent = new Date(nearest.time).toLocaleString('en-US', { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' });
                    ttPrice.textContent = `$${Number(nearest.price).toFixed(2)}`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = Math.min(e.clientX + 10, window.innerWidth - 220) + 'px';
                    tooltip.style.top = (e.clientY - 80) + 'px';
                    if (cursor) { cursor.style.display = 'block'; cursor.style.left = (nearest.x) + 'px'; }
                } else {
                    tooltip.style.display = 'none';
                    if (cursor) cursor.style.display = 'none';
                }
            });

            canvas.addEventListener('mouseleave', () => {
                const tooltip = document.getElementById('drawerTooltip');
                if (tooltip) tooltip.style.display = 'none';
                if (cursor) cursor.style.display = 'none';
            });
        })();

        // Hover interactions for insights chart
        (function initInsightsChartHover(){
            const canvas = document.getElementById('insightsPriceChart');
            if (!canvas) return;
            const tooltip = document.getElementById('priceChartTooltip');
            const ttTime = document.getElementById('priceChartTooltipTime');
            const ttPrice = document.getElementById('priceChartTooltipPrice');
            canvas.addEventListener('mousemove', (e)=>{
                if (!window._insightsPricePoints || window._insightsPricePoints.length===0) return;
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                let nearest=null; let min=Infinity;
                window._insightsPricePoints.forEach(pt=>{ const d = Math.abs(pt.x - mx); if (d<min){min=d; nearest=pt;} });
                if (nearest && min < 40) {
                    const dt = new Date(nearest.time).toLocaleString('en-US',{month:'short',day:'numeric',hour:'2-digit',minute:'2-digit'});
                    ttTime.textContent = dt;
                    ttPrice.textContent = `$${nearest.price.toFixed(2)}`;
                    tooltip.style.display='block';
                    tooltip.style.left = (nearest.x + 16) + 'px';
                    tooltip.style.top = (nearest.y - 34) + 'px';
                } else {
                    tooltip.style.display='none';
                }
            });
            canvas.addEventListener('mouseleave', ()=>{ if (tooltip) tooltip.style.display='none'; });
        })();

        // Responsive resize for insights chart
        window.addEventListener('resize', ()=>{ renderInsightsPriceChart(); });


        // Highlight signal on chart (placeholder - can be enhanced)
        function highlightSignalOnChart(timestamp) {
            console.log('Highlighting signal at timestamp:', timestamp);
            // Future: scroll chart to timestamp and add visual marker
            alert(`Chart highlighting for ${new Date(timestamp).toLocaleString()} - Feature coming soon!`);
        }

        // Update results panel status
        function updateResultsPanelStatus(status) {
            const statusEl = document.getElementById('resultsPanelStatus');
            if (statusEl) {
                statusEl.textContent = status;
            }
        }

        // Hook into workflow execution to update results panel
        const originalRunWorkflow = window.runSequentialWorkflow;
        if (originalRunWorkflow) {
            window.runSequentialWorkflow = async function() {
                updateResultsPanelStatus('Executing...');
                
                try {
                    await originalRunWorkflow.apply(this, arguments);
                    updateResultsPanelStatus('Complete');
                } catch (err) {
                    updateResultsPanelStatus('Error');
                    throw err;
                }
            };
        }

        // Add button to toolbar to toggle results panel
        setTimeout(() => {
            const toolbar = document.querySelector('.toolbar');
            if (toolbar) {
                const btn = document.createElement('button');
                btn.className = 'toolbar-btn insights-btn';
                btn.textContent = 'Insights';
                btn.title = 'Open Strategy Insights Panel (Alt+I)';
                btn.onclick = toggleResultsPanel;
                toolbar.appendChild(btn);
            }
        }, 500);

        // Inject shared logo SVG into login/dashboard placeholders if present
        (async function injectSharedLogo(){
            try {
                const resp = await fetch('./ui/logo.svg');
                if (!resp.ok) return;
                const svgText = await resp.text();
                const ids = ['loginLogo','dashboardHeaderLogo'];
                ids.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = svgText;
                });
            } catch (e) { /* ignore */ }
        })();

        // Keyboard shortcut: Alt+I to toggle results panel
        document.addEventListener('keydown', (e) => {
            if (e.altKey && e.key === 'i') {
                e.preventDefault();
                toggleResultsPanel();
            }
        });

        // Auto-save signal history to localStorage
        function saveSignalHistory() {
            try {
                localStorage.setItem('signal_history', JSON.stringify(window.signalHistory));
            } catch (err) {
                console.warn('Could not save signal history:', err);
            }
        }

        // Restore signal history on load
        function restoreSignalHistory() {
            try {
                const saved = localStorage.getItem('signal_history');
                if (saved) {
                    window.signalHistory = JSON.parse(saved);
                    updateSignalList();
                }
            } catch (err) {
                console.warn('Could not restore signal history:', err);
            }
        }

        // Restore on page load
        setTimeout(restoreSignalHistory, 100);

        // Save on new signal
        const originalAddSignal = addSignalToHistory;
        addSignalToHistory = function(signal) {
            originalAddSignal(signal);
            saveSignalHistory();
        };

        // ========== END PREMIUM RESULTS PANEL ==========
    </script>
</body>
</html>
